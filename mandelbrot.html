<html>
 <head>
  <title>Mandelbrot Explorer</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
  <style>
   body { border:0; margin: 0; background:#9146ff; }
   canvas { border: 0; margin:0; background:#9146ff; }
   #reset { position: fixed; bottom:12px; left:12px; }
   #save { position: fixed; bottom:12px; right:12px; }
  </style>
 </head>
<body>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J4DSMHX8B7"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-J4DSMHX8B7');
    gtag('event', 'screen_view', { 'app_version': '80' });
  </script>
 <canvas id='mycanvas'>
 </canvas>
 <input type="button" value="Reset View" id="reset" onclick="resetFocus();" />
 <input type="button" value="Save PNG" id="save" onclick="savePNG();" />
 <script src="bigfloat.js"></script>
 <script>
const base64wasm =
// BEGIN-WASM-INCLUDE
'AGFzbQEAAAABfRNgA39/fwF/YAF/AX9gA39/fwBgAn9/AGACf38Bf2AEf35+fwBgAAF/YAZ/fH9/' +
'f38Bf2ACfn8Bf2AAAGABfwBgBX9/f39/AGAJf39/f3x8fHx8AGAFf39/f38Bf2ADfn9/AX9gBH9/' +
'fHwBfGACfn4BfGABfAF8YAJ8fwF8AyYlCQMBDA8BEQYAAAEEBAQSAA0CAQIOCAgLBwMFBRACAAIB' +
'AgYKAQQFAXABBQUFBgEBgBCAEAa3ARl/AUHwkMAkC38AQbAPC38AQbQPC38AQbwNC38AQbgPC38A' +
'QcAPC38AQdAPC38AQcANC38AQeCPgCALfwBB6I+AIAt/AEGEkIAgC38AQYiQgCALfwBBkJCAIAt/' +
'AEGYkIAgC38AQdCPgCALfwBB1I+AIAt/AEHYj4AgC38AQfCPgCALfwBB9I+AIAt/AEH4j4AgC38A' +
'QfyPgCALfwBBgJCAIAt/AEG8Dwt/AEGgkIAgC38AQbgNCwfrAiQGbWVtb3J5AgAZX19pbmRpcmVj' +
'dF9mdW5jdGlvbl90YWJsZQEACGpzcHJpbnRmAAEIbG9nc3RhcnQDAQZsb2dsZW4DAgRpbml0AAII' +
'cGl4ZWxNaW4DAwhwaXhlbE1heAMECnBpeGVsQ291bnQDBQRkYXRhAwYJc2V0dXBTaXplAAMGc21v' +
'b3RoAwcGeGZvY3VzAwgGeWZvY3VzAwkDY2R5AwoGZHNjYWxlAwsCangDDAJqeQMNBXdpZHRoAw4G' +
'aGVpZ2h0Aw8HbWF4SXRlcgMQAmN4AxECY3kDEgNjZHgDEwR5cG9zAxQEeHBvcwMVBXBpeGVsAxYK' +
'bWFuZGVsYnJvdAAECGNhbGNXb3JrAAUGY3RhYmxlAxcHbG9nc2l6ZQMYC19pbml0aWFsaXplAAAQ' +
'X19lcnJub19sb2NhdGlvbgAHCXN0YWNrU2F2ZQAiDHN0YWNrUmVzdG9yZQAjCnN0YWNrQWxsb2MA' +
'JAkKAQBBAQsEAAkYGQrMUyUDAAELOwEBfyMAQRBrIgIkACACIAE2AgxBtA9BsA8oAgBBtA8oAgBq' +
'IAAgARAIQbQPKAIAajYCACACQRBqJAALJwEBf0G4D0G8DSgCACIBIAAgACABSBsiADYCAEHADyAA' +
'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' +
'a0ECaiADRSAHIAlrQRJrIANOchsiA2oiDSAEEBcgACAKIA8QESAAQTAgAiANIARBgIAEcxAXIAAg' +
'CUEQaiAHIAlBEGprIgUQESAAQTAgAyAFIBAgDGsiA2prQQBBABAXIAAgDCADEBELIABBICACIA0g' +
'BEGAwABzEBcgCUGwBGokACACIA0gAiANShsLKAAgASABKAIAQQ9qQXBxIgFBEGo2AgAgACABKQMA' +
'IAEpAwgQHDkDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYg' +
'AUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCACIANBQGqt' +
'iCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcD' +
'CAvXAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMCAPH0gBUKAgICAgIDA' +
'/8MAfVQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICA' +
'gIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsg' +
'AFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KA' +
'gICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIinIgNB' +
'kfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANBgfcAaxAaIAIgACAEQYH4ACAD' +
'axAbIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKB' +
'gICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQA' +
'IAQgAUKAgICAgICAgIB/g4S/CzsBAX8gAgRAA0AgACABIAJB/AMgAkH8A0kbIgMQHiEAIAFB/ANq' +
'IQEgAEH8A2ohACACIANrIgINAAsLC4EEAQN/IAJBgARPBEAgACABIAIQHSAADwsgACACaiEDAkAg' +
'ACABc0EDcUUEQAJAIAJBAUgEQCAAIQIMAQsgAEEDcUUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAA' +
'IAFBAWohASACQQFqIgIgA08NASACQQNxDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANA' +
'IAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIU' +
'NgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiAB' +
'KAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFA' +
'ayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJ' +
'BEAgACECDAELIAAgA0EEayIESwRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIg' +
'AS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAA' +
'IAFBAWohASACQQFqIgIgA0cNAAsLIAAL8QICAn8BfgJAIAJFDQAgACACaiIDQQFrIAE6AAAgACAB' +
'OgAAIAJBA0kNACADQQJrIAE6AAAgACABOgABIANBA2sgAToAACAAIAE6AAIgAkEHSQ0AIANBBGsg' +
'AToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgA2AgAgAyACIARr' +
'QXxxIgJqIgFBBGsgADYCACACQQlJDQAgAyAANgIIIAMgADYCBCABQQhrIAA2AgAgAUEMayAANgIA' +
'IAJBGUkNACADIAA2AhggAyAANgIUIAMgADYCECADIAA2AgwgAUEQayAANgIAIAFBFGsgADYCACAB' +
'QRhrIAA2AgAgAUEcayAANgIAIAIgA0EEcUEYciIBayICQSBJDQAgAK0iBUIghiAFhCEFIAEgA2oh' +
'AQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCwtZAQF/' +
'IAAgAC0ASiIBQQFrIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgC' +
'LCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAuoAQEDfwJAIAEgAigCECIEBH8gBAUgAhAgDQEg' +
'AigCEAsgAigCFCIFa0sEQCACIAAgASACKAIkEQAAGg8LAkAgAiwAS0EASA0AIAEhBANAIAQiA0UN' +
'ASAAIANBAWsiBGotAABBCkcNAAsgAiAAIAMgAigCJBEAACADSQ0BIAAgA2ohACABIANrIQEgAigC' +
'FCEFCyAFIAAgARAeGiACIAIoAhQgAWo2AhQLCwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAAL' +
'C6wDEgBBpAgLAQIAQcsICwX//////wBBkAkLEC0rICAgMFgweAAobnVsbCkAQbAJC0ERAAoAERER' +
'AAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAAQAJCwsAAAkGCwAACwAGEQAAABER' +
'EQBBgQoLIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBuwoLAQwAQccKCxUMAAAA' +
'AAwAAAAACQwAAAAAAAwAAAwAQfUKCwEOAEGBCwsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGvCwsB' +
'EABBuwsLHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB8gsLDhIAAAASEhIAAAAAAAAJ' +
'AEGjDAsBCwBBrwwLFQoAAAAACgAAAAAJCwAAAAAACwAACwBB3QwLAQwAQekMC0sMAAAAAAwAAAAA' +
'CQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBu' +
'YW4ATkFOAC4AQbkNCwgQAAAAQAAAAQBB9A4LBEwIQAQ=' +
'';
// END-WASM-INCLUDE

  // **** Postscript-like matrix helper functions: github.com/nlaredo
  //
  // note: Using Float64Array for compiled WASM code
  //
  // initmatrix(a, b, c, d, e, f):
  //
  // if a, b, c, d, e, f undefined, return
  // [ 1, 0,
  //   0, 1,
  //   0, 0 ];
  function initmatrix(a, b, c, d, e, f) {
    let r = new Float64Array(6);
    if (a === undefined) a = 1;
    if (b === undefined) b = 0;
    if (c === undefined) c = 0;
    if (d === undefined) d = 1;
    if (e === undefined) e = 0;
    if (f === undefined) f = 0;
    r[0] = a; r[1] = b;
    r[2] = c; r[3] = d;
    r[4] = e; r[5] = f;
    return r;
  }
  // invert(m):
  //
  //  [ m0, m1, (0)
  //    m2, m3, (0)
  //    m4, m5, (1) ]^-1;  // 0 0 1 column implicit
  function invert(m) {
    let r = new Float64Array(6);
    let det = m[3] - m[2];
    //  [ m0, m2, (m4)
    //    m1, m3, (m5)
    //     0,  0, (1) ];
    r[0] = m[3] / det;
    r[1] = -m[1] / det;
    r[2] = -m[2] / det;
    r[3] = m[0] / det;
    r[4] = (m[2] * m[5] - m[3] * m[4]) / det;
    r[5] = -(m[0] * m[5] - m[1] * m[4]) / det;
    return r;
  }
  // transform(m, x, y):
  //
  // [ x * [ m0, m1, (0)
  //   y     m2, m3, (0)
  //   1 ]   m4, m5, (1) ];  // 0 0 1 column implicit
  function transform(m, inX, inY) {
    let r = new Float64Array(2);
    r[0] = inX * m[0] + inY * m[2] + m[4];
    r[1] = inX * m[1] + inY * m[3] + m[5];
    return r;
  }
  // concat(m1, m2):
  //
  // [ m0, m1, (0) * [ n0, n1, (0)
  //   m2, m3, (0)     n2, n3, (0)
  //   m4, m5, (1)]    n4, n5, (1) ];  // 0 0 1 column implicit
  function concat(m, n) {
    let r = new Float64Array(6);
    r[0] = m[0] * n[0] + m[1] * n[2];
    r[1] = m[0] * n[1] + m[1] * n[3];
    r[2] = m[2] * n[0] + m[3] * n[2];
    r[3] = m[2] * n[1] + m[3] * n[3];
    r[4] = m[4] * n[0] + m[5] * n[2] + n[4];
    r[5] = m[4] * n[1] + m[5] * n[3] + n[5];
    return r;
  }
  function translate(m, x, y) {
    let r = initmatrix(1, 0, 0, 1, x, y);
    return concat(m, r);
  }
  function rotate(m, t) {
    const c = Math.cos(t);  //  c, -s,
    const s = Math.sin(t);  //  s,  c
    let r = initmatrix(c, -s, s, c, 0, 0);
    return concat(m, r);
  }
  function scale(m, sx, sy) {
    let r = initmatrix(sx, 0, 0, sy, 0, 0);
    return concat(m, r);
  }
  // **** End of Postscript-like matrix helper functions: github.com/nlaredo

    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const maxCanvas = 4096 * 4096;
    let data32 = null;  // for 32-bit canvas data access
    let dscale, xfocus, yfocus, radius;
    let dscaleBF, xfocusBF, yfocusBF, radiusBF;  // for arbitrary precision
    const maxRadius = 16;
    let xpos, ypos, cdx, cdy, done;
    let tscale, midX, midY, avgD, tx, ty, cx, cy, width, height;
    let jxBF = new BigFloat(0), jyBF = new BigFloat(0);
    let jx, jy;
    const DEFAULT_MR = 11;
    const DEFAULT_MB = 12;
    const DEFAULT_MG = 13;
    const DEFAULT_I = 888;
    const DEFAULT_G = false;
    const DEFAULT_S = false;
    let mr = DEFAULT_MR;
    let mb = DEFAULT_MB;
    let mg = DEFAULT_MG;
    let grayscale = DEFAULT_G;
    let smooth = DEFAULT_S;
    let workUnit = 1;  // start small to detect refresh rate
    let useWasm = 1;
    let px, pxtot;
    let img = null;
    let png = null;
    let gotPNG = false;
    let maxIter = DEFAULT_I;
    let fracscale = [];

    let wasmptr = null, wasm = null;
    function wasmConsole() {
      const start = new Uint32Array(wasm.memory.buffer, wasm.logstart, 1);
      const len = new Uint32Array(wasm.memory.buffer, wasm.loglen, 1);
      if (len[0] <= 0)
        return;
      const bytes = new Uint8Array(wasm.memory.buffer, start[0], len[0]);
      const s = new TextDecoder('utf8').decode(bytes);
      // mark message as output
      len[0] = 0;
      console.log(s);
    }

    function savePNG() {
      let link = document.createElement("a");
      png.src.replace("img/png", "image/octet-strean");
      link.href = png.src;
      // set suggested filename to contain coordinates and options
      link.download = `mandelbrot${
        encodeURIComponent(window.location.hash)}.png`;
      link.click();
    }
    function drawScaledImageData(i, x, y, s) {
      if ((s != 1 || done) && !gotPNG) {
        ctx.putImageData(i, 0, 0);
        png.src = canvas.toDataURL("image/png");
        gotPNG = true;
      }
      if (gotPNG) {
        ctx.putImageData(i, 0, 0);
        ctx.drawImage(png, x, y, width * s, height * s);
      } else {
        ctx.putImageData(i, x, y);
      }
    }
    function getCurrentImageData() {
        let newImg = ctx.getImageData(0, 0, width, height);
        img.data.set(newImg.data);
        gotPNG = false;
    }

    // given xfocus, yfocus, radius: calc new dscale
    function calcScale() {
      if (!cx || !cy) {
        cx = Math.floor(window.innerWidth/2);
        cy = Math.floor(window.innerHeight/2);
      }
      // per pixel delta
      let pixels = ((cx < cy) ? cx : cy);
      // calculate with bigfloat first
      let pixelsBF = new BigFloat(pixels);
      dscaleBF = new BigFloat(radiusBF);
      dscaleBF.divide(pixelsBF);  // dscaleBF = radiusBF / pixels
      // round over-precise coordinates based on current scale
      const msb = Math.abs(dscaleBF.exponent + dscaleBF.msb) + 5;
      console.log(pixels, msb);
      xfocusBF.normalize(msb);
      yfocusBF.normalize(msb);
      radiusBF.normalize(msb);
      dscaleBF.normalize(msb);
      // convert BigFloat to floats
      dscale = Number(dscaleBF);
      xfocus = Number(xfocusBF);
      yfocus = Number(yfocusBF);
      radius = Number(radiusBF);
      jx = Number(jxBF, msb);
      jy = Number(jyBF, msb);
      xpos = ypos = cdx = 0;
      cdy = -1;
      pxtot = cx * cy * 4; px = 0;
      if (img) saveState();  // only save state *after* first render

      tx = ty = 0;
      tscale = 1;
      midX = cx;
      midY = cy;
      avgD = 0;
      gotPNG = false;
      done = false;
      if (wasm) {
        wasm.setupSize(width, height, maxIter, smooth,
                       xfocus, yfocus, dscale, jx, jy);
      }
    }
    function resetFocus() {
      xfocusBF = new BigFloat(!jx && !jy ? -0.75 : 0);
      yfocusBF = new BigFloat(0);
      radiusBF = new BigFloat(1.25);
      calcScale();
    }
    resetFocus();

    let cctable = null;
    let ctable = [];

    function makeColors() {
      let t = 2 * Math.PI / 256;
      let a = 0;
      // ctable index 0: 145 70 255 (#9146ff)
      const or = Math.asin((145-128)/127);
      const ob = Math.asin((255-128)/127);
      const og = Math.asin((70-128)/127);
      ctable = [];
      for (i = 0; i < maxIter; i++) {
        const r = Math.floor(128 + 127 * Math.sin(a*mr+or));
        const b = Math.floor(128 + 127 * Math.sin(a*mb+ob));
        const g = Math.floor(128 + 127 * Math.sin(a*mg+og));
        a += t;
        t *= Math.pow(0.90, (1 / (i/10+3)));
        if (grayscale) {
          const v = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);
          r = g = b = v;
        }
        if (cctable) {
          cctable[i] = r | (g << 8) | (b << 16) | 0xff000000;
        }
        ctable.push([r, g, b]);
      }
      ctable.push(ctable[0]);
      if (cctable) {
        cctable[i] = cctable[0]
      }
    }

    // BigFloat version of mandelbrot
    function mandelbrotBF(px, py, x0, y0, bits) {
      if (!bits) bits = 16;
      let x = new BigFloat(px - cx, bits);
      x.multiply(dscaleBF);
      x.multiply(xfocusBF);
      let y = new BigFloat(py - cy, bits);
      y.multiply(dscaleBF);
      y.multiply(yfocusBF);
      let xsq = new BigFloat(x, bits);
      xsq.multiply(x);
      let ysq = new BigFloat(y, bits);
      ysq.multiply(y);
      let i = 0;
      if (!x0 && !y0) {  // if these are non-zero, julia; else mandelbrot
        x0 = new BigFloat(x, bits);
        y0 = new BigFloat(y, bits);
      }
      let sum = new BigFloat(0, bits);
      let v256 = new BigFloat(256, bits);
      do {
        // y = 2 * x * y + y0;
        y.multiply(x);
        y.exponent++; // multiply 2;
        y.add(y0);
        // x = xsq - ysq + x0;
        x.assign(ysq);
        x.unaryMinus()
        x.add(xsq);
        x.add(x0);
        // xsq = x * x;
        xsq.assign(x);
        xsq.multiply(x);
        // ysq = y * y;
        ysq.assign(y);
        ysq.multiply(y);
        sum.assign(xsq);
        sum.add(ysq);
        i++;
      } while (i < maxIter && sum.lessThan(v256));
      if (smooth && i < maxIter - 2) {
        let fsum = Number(sum);
        i += 1-Math.log((0.5 * Math.log(fsum))/Math.LN2) / Math.LN2;
      }
      return i; 
    }


    function mandelbrot(px, py, x0, y0) {
      let x = (px - cx) * dscale + xfocus;
      let y = (py - cy) * dscale + yfocus;
      let xsq = x*x;
      let ysq = y*y;
      let i = 0;
      if (!x0 && !y0) {  // if these are non-zero, julia; else mandelbrot
        x0 = x;
        y0 = y;
      }
      do {
        y = 2 * x * y + y0;
        x = xsq - ysq + x0;
        xsq = x * x;
        ysq = y * y;
        i++;
      } while (i < maxIter && xsq + ysq <= 256);
      if (smooth && i < maxIter - 2) {
        i += 1-Math.log((0.5 * Math.log(xsq + ysq))/Math.log(2))/Math.log(2);
      }
      return i; 
    }

    function calcWork() {
      for (let work = 0; !done && work < workUnit; work++) {
        // calculate in spiral from center
        const x = cx + xpos;
        const y = cy + ypos;
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const o = y * width + x;
          const it = mandelbrotBF(x, y, jxBF, jyBF);
          //const it = mandelbrot(x, y, jx, jy);
          let i = Math.floor(it);
          if (smooth && i < maxIter) {
            let e = (i + 1) - it;
            if (i <= 0) i = e = 0;
            const f = 1 - e;
            const c1 = ctable[i];
            const c2 = ctable[i + 1];
            const o4 = o * 4;
            img.data[o4] = Math.floor(c1[0] * e + c2[0] * f);
            img.data[o4 + 1] = Math.floor(c1[1] * e + c2[1] * f);
            img.data[o4 + 2] = Math.floor(c1[2] * e + c2[2] * f);
            img.data[o4 + 3] = 255;
          } else {
            data32[o] = cctable[i]
          }
          px++;
        }
        if ((xpos == ypos) ||
            ((xpos < 0) && (xpos == -ypos)) ||
            ((xpos > 0) && (xpos == 1 - ypos))) {
          const dx = cdx;
          cdx = -cdy;
          cdy = dx;
        }
        xpos += cdx;
        ypos += cdy
      }
    }
    function saveState() {
      window.onhashchange = null;
      let hash=`x=${xfocusBF.toString(64)}&y=${yfocusBF.toString(64)}` +
               `&r=${radiusBF.toString(64)}`;
      const baseUrl = window.location.href.split('#')[0];
      if (jx) hash += `&jx=${jxBF.toString(64)}`;
      if (jy) hash += `&jy=${jyBF.toString(64)}`;
      if (mr != DEFAULT_MR) hash+=`&mr=${mr}`;
      if (mb != DEFAULT_MB) hash+=`&mb=${mb}`;
      if (mg != DEFAULT_MG) hash+=`&mg=${mg}`;
      if (maxIter != DEFAULT_I) hash+=`&i=${maxIter}`;
      if (grayscale != DEFAULT_G) hash+=`&g=${grayscale ? 1 : 0}`;
      if (smooth != DEFAULT_S) hash+=`&s=${smooth ? 1 : 0}`;
      if (!useWasm) hash+='&w=0';
      window.location.replace(baseUrl + '#' + hash);
      window.onhashchange = loadState;
    }
    function loadState() {
      const args = window.location.hash.substr(1).split('&');
      let x, y, r, i, s, g;
      // reset color multipliers that aren't specified in url
      mr = DEFAULT_MR;
      mb = DEFAULT_MB;
      mg = DEFAULT_MG;
      args.forEach(function(arg) {
        const v = arg.split('=');
        if (v.length < 2)
          return;
        const bf = new BigFloat(v[1]);
        const f = Number(bf);
        if (v[0] == "x") x = bf;
        if (v[0] == "y") y = bf;
        if (v[0] == "jx") jx = bf;
        if (v[0] == "jy") jy = bf;
        if (v[0] == "r") r = bf;
        if (v[0] == "mr") mr = f;
        if (v[0] == "mb") mb = f;
        if (v[0] == "mg") mg = f;
        if (v[0] == "i") i = f|0;
        if (v[0] == "s") s = f|0;
        if (v[0] == "g") g = f|0;
        if (v[0] == "w") useWasm = f|0;
      });
      // precision not needed to compare BigFloat with limits
      if (Number(x) > -4 && Number(x) < 4) xfocusBF = x;
      if (Number(y) > -4 && Number(y) < 4) yfocusBF = y;
      if (Number(r) > 0 && Number(r) <= 16) radiusBF = r;
      if (i > 63 && i < 1048576) maxIter = i;
      if (s == 0 || s > 0) smooth = (s > 0);
      if (g == 0 || g > 0) grayscale = (g > 0);
      calcScale();
      makeColors();
      saveState(); // remake the "canonical" url
    }
    loadState();
    function resizeCanvas() {
      const ow = canvas.width;
      const oh = canvas.height;
      const nw = window.innerWidth;
      const nh = window.innerHeight;
      const ncx = Math.floor(nw/2);
      const ncy = Math.floor(nh/2);
      tx = ty = 0;
      tscale = 1;
      done = true;
      if (img) {
        if (!gotPNG) {
          // get a png of current img data to scale into new img
          drawScaledImageData(img, 0, 0, 1);
        }
        const nr = (nh < nw ? nh : nw);
        const or = (oh < ow ? oh : ow);
        updateView(nw - ow, nh - oh, nr / or, ncx, ncy);
      }
      canvas.width = width = nw;
      canvas.height = height = nh;
      cx = ncx;
      cy = ncy

      if (wasmptr && wasm && (img == null || png == null ||
          img.width != width || img.height != height)) {
        const wasmdata = new Uint8ClampedArray(wasm.memory.buffer, wasmptr,
                               canvas.width * canvas.height * 4);
        data32 = new Uint32Array(wasm.memory.buffer, wasmptr, width * height);
        img = new ImageData(wasmdata, width, height);
        //data32.fill(cctable[0]);
        if (gotPNG) {
          // update new image with saved png at appropriate scale
          drawScaledImageData(img, tx, ty, tscale);
          ctx.putImageData(img, 0, 0);
          ctx.drawImage(png, tx, ty, ow * tscale, oh * tscale);
          getCurrentImageData();
        }
        png = new Image(canvas.width, canvas.height);
        if (gotPNG) {
          gotPNG = false;
          done = true;
          drawScaledImageData(img, 0, 0, 1);
        }
      }
      // if tscale/tx/ty updated, updates will happen in animate after
      // a half second timeout
      console.log(gotPNG, tx, ty, tscale);
      if (!gotPNG) calcScale();
    }

    let lasttime = 0;
    let lastmove = 0;
    let refresh = 1000/30;  // 30fps initial budget
    let mouseDown = null;
    let mouseMove = null;
    let mouseOver = null;
    let numTouches = 0;

    let lastMidX = 0;
    let lastMidY = 0;
    function updateView(dx, dy, ds, midX, midY) {
      lastmove = lasttime;
      // calculate new scale and position based on dx, dy, ds
      let sdx = (tx - midX) * ds + midX - tx;
      let sdy = (ty - midY) * ds + midY - ty;
      if (!(midX === undefined || midY === undefined)) {
        lastMidX = midX;
        lastMidY = midY;
      }
      let newTscale = tscale * ds;
      if (radius / newTscale > maxRadius) {
        newTscale = radius / maxRadius;
        const s = newTscale / tscale;
        sdx = (tx - midX) * s + midX - tx;
        sdy = (ty - midY) * s + midY - ty;
      }
      const newRadius = radius / newTscale;
      if (midX === undefined || midY === undefined) {
        sdx = sdy = 0;
      }
      let newTx = tx + dx + sdx;
      let newTy = ty + dy + sdy;
      const centerx = (newTx - cx) / tscale + cx;
      const centery = (newTy - cy) / tscale + cy;
      const newXfocus = xfocus - centerx * dscale;
      const newYfocus = yfocus - centery * dscale;
      // limit x,yfocus to no greater than radius 3 from origin
      const rsquared = newXfocus * newXfocus + newYfocus * newYfocus;
      const mRadius = (newRadius - 3 > 3 ? newRadius - 3 : 3);
      if (rsquared > mRadius * mRadius) {
        const d = Math.sqrt(rsquared);
        const ndx = newXfocus / d;
        const ndy = newYfocus / d;
        newTx += (newXfocus - ndx * mRadius) / dscale;
        newTy += (newYfocus - ndy * mRadius) / dscale;
      }
      // commit valid view
      tx = newTx;
      ty = newTy;
      tscale = newTscale;
    }
    function calcView() {
      // calculate new scale based on last tx, ty, tscale
      let centerx = new BigFloat((tx - cx) / tscale + cx);
      let centery = new BigFloat((ty - cy) / tscale + cy);
      centerx.multiply(dscaleBF);
      centery.multiply(dscaleBF);
      xfocusBF.sub(centerx);
      yfocusBF.sub(centery);
      let ts = new BigFloat(tscale);
      radiusBF.divide(ts);
      drawScaledImageData(img, tx, ty, tscale);
      getCurrentImageData();
      calcScale();
    }
    // handle touch events:
    // find average point of all active touches
    // find average distance from midpoint to active touches
    // for touchmove events only:
    //   tx += last midpoint midX - current midpoint x
    //   ty += last midpoint midY - current midpoint y
    //   update midX, midY to current average midpoint
    //   tscale *= last average distance (avgD) / current average distance
    //   update avgD to current average distance
    // for touchstart/touchend only:
    //   update midX, midY, avgD; no change in tscale or tx, ty
    function touchEvent(event) {
      event.preventDefault();
      done = true;  // stop work if user is interacting
      numTouches = event.touches.length;
      let curMidX = 0, curMidY = 0, curAvgD = 0;
      if (event.touches.length > 0) {
        for (let i = 0; i < numTouches; i++) {
          curMidX += event.touches[i].clientX;
          curMidY += event.touches[i].clientY;
        }
        curMidX /= numTouches;
        curMidY /= numTouches;
        for (let i = 0; i < numTouches; i++) {
          const dx = event.touches[i].clientX - midX;
          const dy = event.touches[i].clientY - midY;
          const d = Math.sqrt(dx * dx + dy * dy);
          curAvgD += d;
        }
        curAvgD /= numTouches;
      }

      if (event.type == "touchend" && !event.touches.length) {
        calcView();
        return;
      }
      if (event.type == "touchcancel") {
        tx = 0;
        ty = 0;
        midX = cx;
        midY = cy;
        tscale = 1;
        avgD = 0;
      }
      if (event.type == "touchmove") {
        updateView(curMidX - midX, curMidY - midY, 1);
        if (numTouches > 1) {
          updateView(0, 0, curAvgD / avgD, curMidX, curMidY);
        }
      }
      midX = curMidX;
      midY = curMidY;
      avgD = curAvgD;
    }
    function mouseWheel(event) {
      event.preventDefault();
      done = true;  // stop work if user is interacting
      const x = event.clientX;
      const y = event.clientY;
      let s = 1;
      if (event.ctrlKey) {  // touchpad pinch
        s = Math.exp(-event.deltaY/20);
      } else {  // scrollwheel
        s = Math.exp(-event.deltaY / 200);
      }
      updateView(0, 0, s, x, y);
    }
    function mouseEvent(event) {
      event.preventDefault();
      if (event.type == "mouseleave") {
        mouseDown = null;
        mouseMove = null;
        return;
      }
      if (event.type == "mousedown") {
        done = true;  // stop work if user is interacting
        mouseDown = event;
      } else if (event.type == "mousemove") {
        mouseMove = event;
        if (mouseDown)
          updateView(event.movementX, event.movementY, 1);
      } else {
        mouseDown = null;
      }
    }
    function centerText(text, y) {
      const t = ctx.measureText(text);
      ctx.fillText(text, cx - t.width/2, y);
      return t.width/2;
    }
    function animate(timestamp) {
	const dt = timestamp - lasttime;
	lasttime = timestamp;
        const pct = Math.floor(100*px/pxtot);
        drawScaledImageData(img, tx, ty, tscale);
        ctx.fillStyle = 'rgba(0,0,0,0.33)';
        ctx.fillRect(0,canvas.height-48,canvas.width, 48);
        ctx.fillStyle = '#f00';
        if (pct < 100) {
          ctx.fillRect(0,canvas.height-48,canvas.width, 5);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(0,canvas.height-48,canvas.width * pct / 100, 5);
        }
        const msb = dscaleBF.exponent + dscaleBF.msb;
        ctx.fillStyle = (msb > -51 ? '#fff' : '#f77');
        ctx.font = '14px Roboto Mono';
        if (jx || jy) {
          centerText(`jx=${jxBF.toString()}   ` +
                     `jy=${jyBF.toString()}`, canvas.height - 32);
        }
        ctx.fillText(msb, cx + centerText(
                `x=${xfocusBF.toString()}   ` +
                `y=${yfocusBF.toString()}   ` +
                `r=${radiusBF.toString()}   2`, canvas.height - 18),
                canvas.height - 28);
        if (mouseMove) {
          const xm = (mouseMove.clientX - cx) * dscale + xfocus;
          const ym = (mouseMove.clientY - cy) * dscale + yfocus;
          centerText(`x=${xm.toExponential(16)}   ` +
                     `y=${ym.toExponential(16)}`, canvas.height - 3);
        }

        const c = [
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/7)),
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/3)),
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/5))
        ];
        ctx.strokeStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
        ctx.fillStyle = `rgb(${c[1]},${c[2]},${c[0]})`;
        if (tx || ty || tscale != 1) {
          const x = (-xfocus / dscale + cx) * tscale + tx;
          const y = (-yfocus / dscale + cy) * tscale + ty;
          const rm = (cx < cy ? 0.5 * cx : 0.5 * cy);
          const cscale = tscale * Math.pow(2, -Math.log2(tscale) - 2);
          const r1 = (10 * cscale);
          const r2 = (2 * rm * cscale);
          ctx.fillText(tscale, lastMidX, lastMidY);
          ctx.beginPath();
          ctx.arc(lastMidX, lastMidY, r1, 0, 2 * Math.PI);
          ctx.arc(lastMidX, lastMidY, r2, 0, 2 * Math.PI);
          ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy);
          ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10);
          ctx.moveTo(x - 10, y - 10); ctx.lineTo(x + 10, y + 10);
          ctx.moveTo(x - 10, y + 10); ctx.lineTo(x + 10, y - 10);
          ctx.stroke();
          if (!mouseDown && !numTouches) {
            // update pending view change if a half second has passed
            if (lasttime - lastmove > 555)
              calcView();
          }
        }
        if (!done) {
          if (useWasm && wasm) {
            px = wasm.calcWork(workUnit);
          } else {
            calcWork();
          }
          done = (px >= pxtot);
        }
        // ctrl key switches to julia view at mouse position
        if (mouseMove && !mouseDown && mouseMove.ctrlKey) {
          const x0 = (mouseMove.clientX - cx) * dscale + xfocus;
          const y0 = (mouseMove.clientY - cy) * dscale + yfocus;
          if (jx != x0 && jy != y0) {
            jxBF = new BigFloat(x0); jyBF = new BigFloat(y0);
            calcScale();
          }
        }
        // alt key switches back to mandelbrot view at mouse position
        if (mouseMove && !mouseDown && mouseMove.altKey) {
          if (jx || jy) {
            jxBF = new BigFloat(0); jyBF = new BigFloat(0);
            calcScale();
          }
        }
        // shift key shows escape at mouse position
        if (mouseMove && !mouseDown && mouseMove.shiftKey) {
          ctx.save();
          ctx.translate(tx, ty);
          ctx.scale(tscale, tscale);
          ctx.strokeStyle = '#ffd';
          let xPt = mouseMove.clientX;
          let yPt = mouseMove.clientY;
          let x = (xPt - cx) * dscale + xfocus;
          let y = (yPt - cy) * dscale + yfocus;
          let i = 0;
          const j = !(!jx && !jy)
          const x0 = (j ? jx : x);
          const y0 = (j ? jy : y);
          const pscale = 1 / dscale;
          ctx.beginPath();
          ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(xPt, yPt);
          let xsq = x*x;
          let ysq = y*y;
          do {
            xPt = (x - xfocus) * pscale + cx;
            yPt = (y - yfocus) * pscale + cy;
            ctx.lineTo(xPt, yPt)
            ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
            y = 2 * x * y + y0;
            x = xsq - ysq + x0;
            xsq = x * x;
            ysq = y * y;
            i++;
          } while (i < 256 && xsq + ysq <= 65536);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
          ctx.fill();
          // show fractional scale around main cardioid
          const tsz = 0.035 / dscale;
          const sz = tsz > 24 ? 24 : tsz;
          ctx.font = `${sz}px Roboto Mono`;
          // generate 60 fractional points around the main cardioid
          if (!fracscale.length) {
            let fr = [], frNext = [];
            for (let i = 1; i < 14; i++) { frNext.push({ n: 1, d:i}); }
            fr.push(frNext.pop());
            while (frNext.length > 0) {
              let next = frNext[frNext.length - 1];
              let last = fr[fr.length - 1];
              if (next.d + last.d < 14) {
                frNext.push({ n: next.n + last.n, d: next.d + last.d });
              } else {
                fr.push(frNext.pop());
              }
            };
            // generate cardioid with points from above fractions
            fr.forEach(function(f) {
              const t = f.n * 2 * Math.PI / f.d;
              // graph r = 1 - cos(t)
              const st = Math.sin(t);
              const ct = Math.cos(t);
              x = .5 * ct - .5 * ct * ct + 0.25;
              y = .5 * st - .5 * ct * st;
              let txt = null;
              let ta = 0;
              if (!(f.n == 1 && f.d == 1)) {
                let r = 0;
                if (f.n/f.d > 1/3 && f.n / f.d <=  2/3)
                  r += Math.PI;
                ta = Math.atan(-1/Math.tan(3 * t / 2)) + r;
                txt = `${f.n}/${f.d}`;
              }
              fracscale.push({ x: x, y: y, t: t, ta: ta, txt: txt });
            });
          }
          ctx.strokeStyle = '#fdf';
          ctx.fillStyle = '#fdf';
          ctx.beginPath();
          // draw crosshairs at 0, 0
          x = -xfocus * pscale + cx; y = -yfocus * pscale + cy;
          ctx.moveTo(x - sz, y); ctx.lineTo(x + sz, y);
          ctx.moveTo(x, y - sz); ctx.lineTo(x, y + sz);
          if (!jx && !jy) {
            let ox = x, oy = y;
            fracscale.forEach(function(e, i) {
              x = (e.x - xfocus) * pscale + cx;
              y = (e.y - yfocus) * pscale + cy;
              if (!i) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
              let dx = x - ox;
              let dy = y - oy;
              if (e.txt && dx * dx + dy * dy > sz * sz + 4) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(e.ta);
                ctx.fillRect(-0.5 * sz, 0, 0.7 * sz, 0.1 * sz);
                ctx.fillText(e.txt, -3.5*sz, 0.5 * sz);
                ctx.restore();
                ox = x; oy = y;
              }
            });
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }

        if (dt < refresh || done) {
            refresh = dt;
        }
        // adjust work unit size to match available time budget
        if (!done) {
          refresh += 1; // relax threshold to point of correction
          if (dt > refresh && workUnit > 1) {
            workUnit = Math.floor(workUnit * 0.75);
          } else {
            workUnit += Math.floor(1048576 / maxIter);
          }
        }
	requestAnimationFrame(animate);
        wasmConsole();
    }

    const pfft = {passive:false};
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('mouseup', mouseEvent, pfft);
    canvas.addEventListener('mousedown', mouseEvent, pfft);
    canvas.addEventListener('mousemove', mouseEvent, pfft);
    canvas.addEventListener('mouseleave', mouseEvent, pfft);
    canvas.addEventListener('wheel', mouseWheel, pfft);
    canvas.addEventListener('scroll', mouseWheel, pfft);
    canvas.addEventListener('touchstart', touchEvent, pfft);
    canvas.addEventListener('touchend', touchEvent, pfft);
    canvas.addEventListener('touchmove', touchEvent, pfft);
    canvas.addEventListener('touchcancel', touchEvent, pfft);

    const decode = (b64) => {
      const a = Uint8Array.from(atob(base64wasm), c => c.charCodeAt(0));
      return a.buffer;
    };

    WebAssembly.instantiate(new Uint8Array(decode(base64wasm))
    ).then(result => {
      wasm = result.instance.exports;
      wasmptr = wasm.init(maxCanvas);  // setup max expected size
      cctable = new Uint32Array(wasm.memory.buffer, wasm.ctable, 1048576);
      makeColors();
      resizeCanvas();
      window.requestAnimationFrame(animate);
    });

 </script>

</body>
</html>
