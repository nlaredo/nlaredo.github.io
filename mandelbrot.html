<html>
 <head>
  <title>Mandelbrot Explorer</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
  <style>
   body { border:0; margin: 0; background:#9146ff; }
   canvas { border: 0; margin:0; background:#9146ff; }
   #reset { position: fixed; bottom:12px; left:12px; }
   #save { position: fixed; bottom:12px; right:12px; }
  </style>
 </head>
<body>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J4DSMHX8B7"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-J4DSMHX8B7');
    gtag('event', 'screen_view', { 'app_version': '45' });
  </script>
 <canvas id='mycanvas'>
 </canvas>
 <input type="button" value="Reset View" id="reset" onclick="resetFocus();" />
 <input type="button" value="Save PNG" id="save" onclick="savePNG();" />
 <script>
const base64wasm =
// BEGIN-WASM-INCLUDE
'AGFzbQEAAAABfRNgA39/fwF/YAF/AX9gA39/fwBgAn9/AGACf38Bf2AEf35+fwBgAAF/YAZ/fH9/' +
'f38Bf2ACfn8Bf2AAAGABfwBgBX9/f39/AGAJf39/f3x8fHx8AGAFf39/f38Bf2ADfn9/AX9gBH9/' +
'fHwBfGACfn4BfGABfAF8YAJ8fwF8AyYlCQMBDA8BEQYAAAEEBAQSAA0CAQIOCAgLBwMFBRACAAIB' +
'AgYKAQQFAXABBQUFBgEBgBCAEAa3ARl/AUHwkMAkC38AQbAPC38AQbQPC38AQbwNC38AQbgPC38A' +
'QcAPC38AQdAPC38AQcANC38AQeCPgCALfwBB6I+AIAt/AEGEkIAgC38AQYiQgCALfwBBkJCAIAt/' +
'AEGYkIAgC38AQdCPgCALfwBB1I+AIAt/AEHYj4AgC38AQfCPgCALfwBB9I+AIAt/AEH4j4AgC38A' +
'QfyPgCALfwBBgJCAIAt/AEG8Dwt/AEGgkIAgC38AQbgNCwfrAiQGbWVtb3J5AgAZX19pbmRpcmVj' +
'dF9mdW5jdGlvbl90YWJsZQEACGpzcHJpbnRmAAEIbG9nc3RhcnQDAQZsb2dsZW4DAgRpbml0AAII' +
'cGl4ZWxNaW4DAwhwaXhlbE1heAMECnBpeGVsQ291bnQDBQRkYXRhAwYJc2V0dXBTaXplAAMGc21v' +
'b3RoAwcGeGZvY3VzAwgGeWZvY3VzAwkDY2R5AwoGZHNjYWxlAwsCangDDAJqeQMNBXdpZHRoAw4G' +
'aGVpZ2h0Aw8HbWF4SXRlcgMQAmN4AxECY3kDEgNjZHgDEwR5cG9zAxQEeHBvcwMVBXBpeGVsAxYK' +
'bWFuZGVsYnJvdAAECGNhbGNXb3JrAAUGY3RhYmxlAxcHbG9nc2l6ZQMYC19pbml0aWFsaXplAAAQ' +
'X19lcnJub19sb2NhdGlvbgAHCXN0YWNrU2F2ZQAiDHN0YWNrUmVzdG9yZQAjCnN0YWNrQWxsb2MA' +
'JAkKAQBBAQsEAAkYGQrMUyUDAAELOwEBfyMAQRBrIgIkACACIAE2AgxBtA9BsA8oAgBBtA8oAgBq' +
'IAAgARAIQbQPKAIAajYCACACQRBqJAALJwEBf0G4D0G8DSgCACIBIAAgACABSBsiADYCAEHADyAA' +
'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' +
'a0ECaiADRSAHIAlrQRJrIANOchsiA2oiDSAEEBcgACAKIA8QESAAQTAgAiANIARBgIAEcxAXIAAg' +
'CUEQaiAHIAlBEGprIgUQESAAQTAgAyAFIBAgDGsiA2prQQBBABAXIAAgDCADEBELIABBICACIA0g' +
'BEGAwABzEBcgCUGwBGokACACIA0gAiANShsLKAAgASABKAIAQQ9qQXBxIgFBEGo2AgAgACABKQMA' +
'IAEpAwgQHDkDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYg' +
'AUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCACIANBQGqt' +
'iCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcD' +
'CAvXAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMCAPH0gBUKAgICAgIDA' +
'/8MAfVQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICA' +
'gIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsg' +
'AFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KA' +
'gICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIinIgNB' +
'kfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANBgfcAaxAaIAIgACAEQYH4ACAD' +
'axAbIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKB' +
'gICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQA' +
'IAQgAUKAgICAgICAgIB/g4S/CzsBAX8gAgRAA0AgACABIAJB/AMgAkH8A0kbIgMQHiEAIAFB/ANq' +
'IQEgAEH8A2ohACACIANrIgINAAsLC4EEAQN/IAJBgARPBEAgACABIAIQHSAADwsgACACaiEDAkAg' +
'ACABc0EDcUUEQAJAIAJBAUgEQCAAIQIMAQsgAEEDcUUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAA' +
'IAFBAWohASACQQFqIgIgA08NASACQQNxDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANA' +
'IAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIU' +
'NgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiAB' +
'KAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFA' +
'ayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJ' +
'BEAgACECDAELIAAgA0EEayIESwRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIg' +
'AS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAA' +
'IAFBAWohASACQQFqIgIgA0cNAAsLIAAL8QICAn8BfgJAIAJFDQAgACACaiIDQQFrIAE6AAAgACAB' +
'OgAAIAJBA0kNACADQQJrIAE6AAAgACABOgABIANBA2sgAToAACAAIAE6AAIgAkEHSQ0AIANBBGsg' +
'AToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgA2AgAgAyACIARr' +
'QXxxIgJqIgFBBGsgADYCACACQQlJDQAgAyAANgIIIAMgADYCBCABQQhrIAA2AgAgAUEMayAANgIA' +
'IAJBGUkNACADIAA2AhggAyAANgIUIAMgADYCECADIAA2AgwgAUEQayAANgIAIAFBFGsgADYCACAB' +
'QRhrIAA2AgAgAUEcayAANgIAIAIgA0EEcUEYciIBayICQSBJDQAgAK0iBUIghiAFhCEFIAEgA2oh' +
'AQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCwtZAQF/' +
'IAAgAC0ASiIBQQFrIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgC' +
'LCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAuoAQEDfwJAIAEgAigCECIEBH8gBAUgAhAgDQEg' +
'AigCEAsgAigCFCIFa0sEQCACIAAgASACKAIkEQAAGg8LAkAgAiwAS0EASA0AIAEhBANAIAQiA0UN' +
'ASAAIANBAWsiBGotAABBCkcNAAsgAiAAIAMgAigCJBEAACADSQ0BIAAgA2ohACABIANrIQEgAigC' +
'FCEFCyAFIAAgARAeGiACIAIoAhQgAWo2AhQLCwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAAL' +
'C6wDEgBBpAgLAQIAQcsICwX//////wBBkAkLEC0rICAgMFgweAAobnVsbCkAQbAJC0ERAAoAERER' +
'AAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAAQAJCwsAAAkGCwAACwAGEQAAABER' +
'EQBBgQoLIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBuwoLAQwAQccKCxUMAAAA' +
'AAwAAAAACQwAAAAAAAwAAAwAQfUKCwEOAEGBCwsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGvCwsB' +
'EABBuwsLHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB8gsLDhIAAAASEhIAAAAAAAAJ' +
'AEGjDAsBCwBBrwwLFQoAAAAACgAAAAAJCwAAAAAACwAACwBB3QwLAQwAQekMC0sMAAAAAAwAAAAA' +
'CQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBu' +
'YW4ATkFOAC4AQbkNCwgQAAAAQAAAAQBB9A4LBEwIQAQ=' +
'';
// END-WASM-INCLUDE

  // **** Postscript-like matrix helper functions: github.com/nlaredo
  //
  // note: Using Float64Array for compiled WASM code
  //
  // initmatrix(a, b, c, d, e, f):
  //
  // if a, b, c, d, e, f undefined, return
  // [ 1, 0,
  //   0, 1,
  //   0, 0 ];
  function initmatrix(a, b, c, d, e, f) {
    let r = new Float64Array(6);
    if (a === undefined) a = 1;
    if (b === undefined) b = 0;
    if (c === undefined) c = 0;
    if (d === undefined) d = 1;
    if (e === undefined) e = 0;
    if (f === undefined) f = 0;
    r[0] = a; r[1] = b;
    r[2] = c; r[3] = d;
    r[4] = e; r[5] = f;
    return r;
  }
  // invert(m):
  //
  //  [ m0, m1, (0)
  //    m2, m3, (0)
  //    m4, m5, (1) ]^-1;  // 0 0 1 column implicit
  function invert(m) {
    let r = new Float64Array(6);
    let det = m[3] - m[2];
    //  [ m0, m2, (m4)
    //    m1, m3, (m5)
    //     0,  0, (1) ];
    r[0] = m[3] / det;
    r[1] = -m[1] / det;
    r[2] = -m[2] / det;
    r[3] = m[0] / det;
    r[4] = (m[2] * m[5] - m[3] * m[4]) / det;
    r[5] = -(m[0] * m[5] - m[1] * m[4]) / det;
    return r;
  }
  // transform(m, x, y):
  //
  // [ x * [ m0, m1, (0)
  //   y     m2, m3, (0)
  //   1 ]   m4, m5, (1) ];  // 0 0 1 column implicit
  function transform(m, inX, inY) {
    let r = new Float64Array(2);
    r[0] = inX * m[0] + inY * m[2] + m[4];
    r[1] = inX * m[1] + inY * m[3] + m[5];
    return r;
  }
  // concat(m1, m2):
  //
  // [ m0, m1, (0) * [ n0, n1, (0)
  //   m2, m3, (0)     n2, n3, (0)
  //   m4, m5, (1)]    n4, n5, (1) ];  // 0 0 1 column implicit
  function concat(m, n) {
    let r = new Float64Array(6);
    r[0] = m[0] * n[0] + m[1] * n[2];
    r[1] = m[0] * n[1] + m[1] * n[3];
    r[2] = m[2] * n[0] + m[3] * n[2];
    r[3] = m[2] * n[1] + m[3] * n[3];
    r[4] = m[4] * n[0] + m[5] * n[2] + n[4];
    r[5] = m[4] * n[1] + m[5] * n[3] + n[5];
    return r;
  }
  function translate(m, x, y) {
    let r = initmatrix(1, 0, 0, 1, x, y);
    return concat(m, r);
  }
  function rotate(m, t) {
    const c = Math.cos(t);  //  c, -s,
    const s = Math.sin(t);  //  s,  c
    let r = initmatrix(c, -s, s, c, 0, 0);
    return concat(m, r);
  }
  function scale(m, sx, sy) {
    let r = initmatrix(sx, 0, 0, sy, 0, 0);
    return concat(m, r);
  }
  // **** End of Postscript-like matrix helper functions: github.com/nlaredo

  // **** BigFloat arbitrary precision math: github.com/nlaredo
  const b64digits =
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~_';
  class BigFloat {
    constructor(f, bits) {
      if (f instanceof BigFloat) {
        // fast case, copy a bigfloat to a new one
        // maybe with different precision in bits
        this.assign(f);
        this.bits = (bits ? bits : f.bits);
        if (this.bits != f.bits)
          this.normalize();
        return this;
      }
      const bias = 0x3ff;
      const expLen = 11;
      // start with clearly invalid values in case of failed parse
      this.sign = 1n;
      this.exponent = 0;
      this.mantissa = 0n;
      this.msb = 0;
      this.bits = bits;
      if (typeof(f) == "bigint") {
        this.sign = f < 0 ? -1n : 1n;
        this.exponent = 0;
        this.mantissa = this.sign * f;
      } else if (typeof(f) == "string") {
        return this.fromString(f);
      } else if (!isNaN(f)) {
        const buf = new ArrayBuffer(8);
        const f64 = new Float64Array(buf);
        const u32 = new Uint32Array(buf);
        const u8 = new Uint8Array(buf);
        u32[1] = 1;
        const upper = u8[4];
        const lower = 1 - upper;
        let expPos, signPos, fracLen = 52;
        fracLen &= 31; expPos = fracLen; signPos = expPos + expLen;
        f64[0] = f;
        const signbit = (u32[upper] >> signPos) & 1;
        this.exponent = ((u32[upper] >> expPos) &
                          ((1 << expLen) - 1));
        const fracLow = u32[lower];
        const fracHigh = u32[upper] & ((1 << fracLen) - 1);
        this.sign = BigInt(signbit ? -1 : 1);
        if (this.exponent == 0x7ff) {
          // NaN (zero mantissa) or Infinity (nonzero mantissa)
          this.exponent = 0;  // squash signal values (Float64 exponent)
        }
        if (!this.exponent && !fracHigh && !fracLow) {
          this.msb = 1;  // exact zero
        } else {
          // only set if not exact zero
          this.mantissa = (1n << 52n) + (BigInt(fracHigh) << 32n) +
                           BigInt(fracLow);
          this.exponent -= bias + 52;
          this.msb = 53;
        }
      }
      this.normalize();
      return this;
    }
    assign(f) {
      this.exponent = f.exponent;
      this.mantissa = f.mantissa;
      this.sign = f.sign;
      this.msb = f.msb;
    }
    findMSB(v) {
      let msb = 0;
      // assume BigInt optimized for right shift 64 bits
      for (let i = 2; i > 0; i--) {
        do {
          let last = v;
          v >>= BigInt(32 * i);
          if (v) {
            msb += 32 * i;
          } else {
            v = last;
            break;
          }
        } while(true);
      }
      // v is now < 32 bits
      return msb + 31 - Math.clz32(Number(v));
    }
    normalize(b) {
      if (b) this.bits = b;
      if (!this.mantissa) {
        this.msb = 0;
        return;
      }
      this.msb = this.findMSB(this.mantissa);
      if (this.bits > 0) {
        const fbits = this.msb - this.bits - 1;
        if (fbits > 0) {
          const bits = BigInt(fbits);
          this.msb -= fbits;
          this.exponent += fbits;
          const rbit = (1n << (bits - 1n)) & this.mantissa;
          this.mantissa >>= bits;
          this.mantissa += (rbit ? 1n : 0n);
        }
      }
      while (!(this.mantissa & 1n)) {
        this.mantissa >>= 1n;
        this.exponent++;
        this.msb--;
      }
      /* slower:
      // to reduce calculation size, make sure lsb = 1
      // search msb in mask of only least significant set bit
      let pos = this.findMSB(this.mantissa & -this.mantissa);
      this.mantissa >>= BigInt(pos);
      this.exponent += pos;
      this.msb -= pos;
      */
    }
    f52() {
      // return new BigFloat with mantissa compatible with 53-bit mantissa
      // and even exponent for using to create first guess with FPU
      const f52 = new BigFloat(this, 51);
      if (f52.exponent & 1) {
        // make sure lower bit of exponent is zero
        f52.mantissa <<= 1n;
        f52.exponent--;
        f52.msb++;
      }
      return f52;
    }
    unaryMinus() { this.sign = -this.sign; }
    exponentiate(y) { console.log("expontiate"); }
    multiply(b) {
      let bVal = b.mantissa;
      let bExp = b.exponent;
      if (this.msb + b.msb > this.bits) {
        // try to restrict result of multiply to desired bits
        let bits = this.bits >> 1;
        if (this.msb > bits) {
          let shift = this.msb - bits;
          this.mantissa >>=  BigInt(shift);
          this.exponent += shift;
        }
        if (b.msb > bits) {
          let shift = b.msb - bits;
          bVal >>=  BigInt(shift);
          bExp += shift;
        }
      }
      this.exponent += bExp;
      this.mantissa *= bVal;
      if (!this.mantissa) {
        this.exponent = 0;
        this.msb = 1;
      }
      this.sign *= b.sign;
      this.normalize();
    }
    divide(b) {
      if (!b.mantissa) {  // divide by zero
        this.exponent = 0;
        this.mantissa = 0n;
        this.msb = 0;
      } else {
        // calculate 64 bits of precision if not set in destination
        const bits = (this.bits ? this.bits : 64) + 5;
        const bExp = 2*bits + this.msb + b.msb;
        this.mantissa <<= BigInt(bExp);
        this.mantissa /= b.mantissa;
        this.exponent -= b.exponent + bExp;
        let oldbits = this.bits;
        this.bits = bits - 5;
        this.normalize();
        this.bits = oldbits;
      }
    }
    remainder(b) { console.log("remainder"); }
    add(b) {
      const expdiff = this.exponent - b.exponent;
      if (expdiff >= 0) {
        if (expdiff > b.bits) {
        }
        this.exponent -= expdiff;
        this.mantissa =
              this.sign * (this.mantissa << BigInt(expdiff)) +
              b.sign * b.mantissa;
      } else {
        this.mantissa =
              this.sign * this.mantissa +
              b.sign * (b.mantissa << BigInt(-expdiff));
      }
      if (this.mantissa < 0n) {
        this.sign = -1n;
        this.mantissa = -this.mantissa;
      } else {
        this.sign = 1n;
      }
      this.normalize();
    }
    compare(b) {
      // only compare mantissas if signs are identical
      if (this.sign != b.sign) { return (this.sign > b.sign ? 1 : -1); }
      const expdiff = this.exponent - b.exponent;
      let val;
      if (expdiff >= 0) {
        // only compare mantissas if exponents show overlap
        if (expdiff > b.bits || expdiff > b.msb) return 1;
        val = (this.mantissa << BigInt(expdiff)) - b.mantissa;
      } else {
        if (-expdiff > b.bits || -expdiff > b.msb) return -1;
        val = this.mantissa - (b.mantissa << BigInt(-expdiff));
      }
      if (!val) return 0;
      val *= this.sign;
      return val < 0n ? -1 : 1;
    }
    lessThan(b) { return (this.compare(b) < 0); }
    equal(b) { return (this.compare(b) == 0); }
    greaterThan(b) { return (this.compare(b) > 0); }
    sub(b) {
      b.unaryMinus();
        // only compare mantissas if exponents show overlap
      this.add(b);
      b.unaryMinus();
    }
    abs() { this.sign = 1n; }
    acosh() { console.log("acosh"); }
    asin() { console.log("asin"); }
    asinh() { console.log("asinh"); }
    atan() {
      const bits = (this.bits ? this.bits : 64);
      // series: atan(x) = x - x**3 / 3 + x**5 / 5 - x**7 / 7 + ...
      const m = this.sign;
      this.abs();
      let x = new BigFloat(this, bits + 5);
      let d = new BigFloat(1, bits);
      let f = new BigFloat(0, bits);
      let a = new BigFloat(0, bits);
      let two = new BigFloat(2, bits);
      let pt2 = new BigFloat("0.2", bits);
      // precondition x
      if (x.greaterThan(pt2)) {
        a = new BigFloat(pt2, bits);
        a.atan();
      }
      while (x.greaterThan(pt2)) {
        f.add(d); // f = f+1
        // x = (x - .2) * (1 + x * .2)
        let x1 = new BigFloat(x, bits);
        x1.multiply(pt2);
        x1.add(d); // +1
        x.sub(pt2);
        x.divide(x1);
      }
      // initialize the series
      let sum = new BigFloat(x, bits + 5);
      let xx = new BigFloat(x, bits);
      xx.sign = -xx.sign;
      xx.multiply(x);  // xx = -x * x
      while (true) {
        x.multiply(xx);
        d.add(two);
        let term = new BigFloat(x, bits);
        term.divide(d);
        sum.add(term);
        if (term.msb + term.exponent < -bits-2) {
          break;
        }
      };
      f.multiply(a);
      sum.add(f);
      sum.sign *= m;
      this.exponent = sum.exponent;
      this.mantissa = sum.mantissa;
      this.sign = sum.sign;
      this.normalize();
    }
    atan2(y) { console.log("atan2"); }
    atanh() { console.log("atanh"); }
    cbrt() { console.log("cbrt (cube root)"); }
    ciel() { console.log("ciel"); }
    cos() { console.log("cos"); }
    cosh() { console.log("cosh"); }
    exp() { console.log("exp"); }
    expm1() { console.log("expm1"); }
    floor() { console.log("floor"); }
    hypot() { console.log("hypot"); }
    log() { console.log("log"); }
    max(a,b) { console.log("max"); }
    min(a,b) { console.log("min"); }
    pow(y) { console.log("pow"); }
    round() { console.log("round"); }
    sign() { console.log("sign"); }
    sin() { console.log("sin"); }
    sinh() { console.log("sinh"); }
    reciprocal() {  // calculate 1/x
      a = new BigFloat(1, this.bits);
      a.divide(this);
      this.assign(a);
      return;

      /* slower
      const bits = this.bits ? this.bits : 64;
      const f52 = this.f52();
      let x = new BigFloat(1 / Number(f52.mantissa));
      x.exponent -= f52.exponent;
      let n = x.msb + x.exponent;
      x.exponent -= n;
      this.exponent += n;
      this.sign = -1n;  // treat input as always positive
      let two = new BigFloat(2);
      do {
        // newton:
        // repeat x = x * (2 - x * this) while x changes bits
        let y = new BigFloat(x, bits);
        let xx = new BigFloat(this, bits + 5);  // xx = -this
        xx.multiply(x);  // xx = -x * this
        xx.add(two);  // xx = 2 - x * this
        x.bits = bits;  // round next op to requested bits
        x.multiply(xx); // x = x * (2 - x * this)
        x.bits = bits + 5; // more bits next loop for rounding
        if (x.equal(y)) break;
      } while (true);
      this.exponent = x.exponent + n;
      this.mantissa = x.mantissa;
      this.msb = x.msb;
      this.sign = f52.sign;
      */
    }
    rsqrt() {
      const bits = this.bits ? this.bits : 64;
      const f52 = this.f52();
      // get initial guess for 53-bit square root from the fpu
      let x = new BigFloat(Math.sqrt(Number(f52.mantissa)), bits + 5);
      x.exponent += Math.floor(f52.exponent/2);
      x.reciprocal();
      let half = new BigFloat(0.5);
      let three = new BigFloat(3);
      do {
        // newton:
        // repeat x = 0.5 * x * (3 - this * x * x) while x changes bits
        let y = new BigFloat(x, bits);
        let xx = new BigFloat(x, bits + 5);
        xx.multiply(x);
        xx.multiply(this);
        xx.unaryMinus();  // xx = -this * x * x
        xx.add(three);
        x.multiply(xx);
        x.bits = bits;  // round next op to requested bits
        x.multiply(half);
        x.bits = bits + 5; // more bits next loop for rounding
        console.log(x);
        if (x.equal(y)) break;
      } while (true);
      this.assign(x);
      this.abs();
    }
    sqrt() {
      let x = new BigFloat(this);
      x.rsqrt();
      this.multiply(x);
    }
    tan() { console.log("tan"); }
    tanh() { console.log("tanh"); }
    trunc() { console.log("trunc"); }
    fromBaseString(str, base) {
      if (!base || base < 2 || base > 64) base = 10;
      let b = BigInt(base);
      let f = new BigFloat(0, this.bits);
      let decimal = null;
      if (str) Array.from(str, x => {
        if (x == '-') {
          f.sign = -f.sign;
        } else if (x == '.') {
          decimal = 0;
        } else if (x != '+') {
          const v = b64digits.indexOf(x);
          if (v > base) {
            throw new RangeError(`${x}(${v}) out of range for base ${base}.`);
          }
          if (v >= 0) {
            f.mantissa = f.mantissa * b + BigInt(v);
            if (decimal != null) {
              decimal++;
            }
          }
        }
      });
      if (decimal > 0) {
        if (base == 10) {
          f.exponent = -decimal;  // base 10 decimal position
        } else {
          f.exponent -= Math.ceil(decimal * Math.log2(base));
        }
      }
      return f;
    }
    fromString(str) {
       const b64 = str.split('@');
       const b10 = str.split('e');
       if (b64.length != 2 && !b10[0].length)
         throw new RangeError("Invalid BaseN number");
       const base = (b64.length == 2 ?
                     1+b64digits.indexOf(b64[1].substring(0,1)) : 10);
       if (base < 2)
         throw new RangeError("Invalid base identifier after @");
       const val = (b64.length == 2 ? b64[0] : b10[0]);
       const exp = (b64.length == 2 ? b64[1].substring(1) : b10[1]);
       const m = this.fromBaseString(val, base);
       const e = this.fromBaseString(exp, base);
       this.mantissa = m.mantissa;
       this.exponent = m.exponent +
                       Number(e.sign * (e.mantissa << BigInt(e.exponent)));
       if (base == 10 && this.exponent != 0) {
         // deal with power of ten exponents
         const e10 = this.exponent;
         this.exponent = 0;
         const p10 = new BigFloat(10n**BigInt(Math.abs(e10)));
         if (e10 < 0) { this.divide(p10); } else { this.multiply(p10); }
       }
       this.sign = m.sign;
       this.normalize();
    }
    toBaseString(val, base, shift, sign) {
      if (!val && !shift) return '+0';
      if (!val) return '0';
      if (!base || base < 2 || base > 64) base = 10;
      let neg = (!sign ? val < 0n : sign < 0n);
      if (val < 0n) val = -val;
      let trim = (shift && shift.digits != undefined);
      let decimal = trim;
      if (typeof(val) != "bigint") val = BigInt(val);
      let parts = [];
      // base**8 = max 48-bit chunk to handle to fit in javascript Number
      const b8n = BigInt(base * base * base * base *
                         base * base * base * base);
      while (val) {
        let bits = Number(val % b8n);
        val /= b8n;
        for (let i = 0; i < 8 && (bits || val); i++) {
          let v = bits % base;
          if (trim && shift && !v) {
            shift.digits++;
          } else {
            trim = false;  // disable throwing away low bits
            if (decimal) {
              if (bits < base && !val) {
                if (parts.length) parts.push('.');
              } else 
                shift.digits++;
            }
            parts.push(b64digits.charAt(bits % base));
          }
          bits = Math.floor(bits / base);
        }
      }
      if (neg) {
        parts.push('-');
      } else {
        if (!decimal) parts.push('+');
      }
      parts.reverse();
      return parts.join('');
    }
    toString(base) {
      if (this.mantissa === undefined || this.exponent === undefined) {
        return "0";
      }
      if (!base || base < 2 || base > 64) base = 10;
      if (this.mantissa < 0n) {
        this.mantissa = -this.mantissa;
        this.sign = -this.sign;
      }
      let exp = this.exponent;
      let val = this.mantissa;
      if (exp >= 0) {
        val <<= BigInt(exp);
        exp = 0;
      }
      if (base == 10 && exp < 0) {
        // figure out the number of base ten digits reqired to make
        // base 10 exponents work...
        const e10 = Math.ceil(this.msb * Math.LN2 / Math.LN10) + 1;
        val *= 10n**BigInt(e10);
        val >>= BigInt(-exp);
        exp = -e10;
      }
      let shift = { digits:0 };
      let mStr = this.toBaseString(val, base, shift, this.sign);
      let eStr = (base == 10 ? '' : '@' + b64digits.charAt(base - 1));
      exp += (base == 10 ? shift.digits :
              Math.ceil(shift.digits * Math.log2(base)));
      if (exp) {
        eStr += (base == 10 ? 'e' : '') + this.toBaseString(exp, base);
      }
      return mStr + eStr;

    }
  }
  // **** End of BigFloat arbitrary precision math: github.com/nlaredo


    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const maxCanvas = 4096 * 4096;
    let data32 = null;  // for 32-bit canvas data access
    let dscale, xfocus, yfocus, radius;
    let dscaleBF, xfocusBF, yfocusBF, radiusBF;  // for arbitrary precision
    const maxRadius = 16;
    let xpos, ypos, cdx, cdy, done;
    let tscale, midX, midY, avgD, tx, ty, cx, cy, width, height;
    let jxBF = new BigFloat(0), jyBF = new BigFloat(0);
    let jx, jy;
    const DEFAULT_MR = 11;
    const DEFAULT_MB = 12;
    const DEFAULT_MG = 13;
    const DEFAULT_I = 888;
    const DEFAULT_G = false;
    const DEFAULT_S = false;
    let mr = DEFAULT_MR;
    let mb = DEFAULT_MB;
    let mg = DEFAULT_MG;
    let grayscale = DEFAULT_G;
    let smooth = DEFAULT_S;
    let workUnit = 1;  // start small to detect refresh rate
    let useWasm = 1;
    let px, pxtot;
    let img = null;
    let png = null;
    let gotPNG = false;
    let maxIter = DEFAULT_I;
    let fracscale = [];

    let wasmptr = null, wasm = null;
    function wasmConsole() {
      const start = new Uint32Array(wasm.memory.buffer, wasm.logstart, 1);
      const len = new Uint32Array(wasm.memory.buffer, wasm.loglen, 1);
      if (len[0] <= 0)
        return;
      const bytes = new Uint8Array(wasm.memory.buffer, start[0], len[0]);
      const s = new TextDecoder('utf8').decode(bytes);
      // mark message as output
      len[0] = 0;
      console.log(s);
    }

    function savePNG() {
      let link = document.createElement("a");
      png.src.replace("img/png", "image/octet-strean");
      link.href = png.src;
      // set suggested filename to contain coordinates and options
      link.download = `mandelbrot${
        encodeURIComponent(window.location.hash)}.png`;
      link.click();
    }
    function drawScaledImageData(i, x, y, s) {
      if ((s != 1 || done) && !gotPNG) {
        ctx.putImageData(i, 0, 0);
        png.src = canvas.toDataURL("image/png");
        gotPNG = true;
      }
      if (gotPNG) {
        ctx.putImageData(i, 0, 0);
        ctx.drawImage(png, x, y, width * s, height * s);
      } else {
        ctx.putImageData(i, x, y);
      }
    }
    function getCurrentImageData() {
        let newImg = ctx.getImageData(0, 0, width, height);
        img.data.set(newImg.data);
        gotPNG = false;
    }

    // given xfocus, yfocus, radius: calc new dscale
    function calcScale() {
      if (!cx || !cy) {
        cx = Math.floor(window.innerWidth/2);
        cy = Math.floor(window.innerHeight/2);
      }
      // per pixel delta
      let pixels = ((cx < cy) ? cx : cy);
      // calculate with bigfloat first
      let pixelsBF = new BigFloat(pixels);
      dscaleBF = new BigFloat(radiusBF);
      dscaleBF.divide(pixelsBF);  // dscaleBF = radiusBF / pixels
      // round over-precise coordinates based on current scale
      const msb = Math.abs(dscaleBF.exponent + dscaleBF.msb) + 5;
      console.log(pixels, msb);
      xfocusBF.normalize(msb);
      yfocusBF.normalize(msb);
      radiusBF.normalize(msb);
      dscaleBF.normalize(msb);
      // convert BigFloat to floats
      dscale = Number(dscaleBF);
      xfocus = Number(xfocusBF);
      yfocus = Number(yfocusBF);
      radius = Number(radiusBF);
      jx = Number(jxBF, msb);
      jy = Number(jyBF, msb);
      xpos = ypos = cdx = 0;
      cdy = -1;
      pxtot = cx * cy * 4; px = 0;
      if (img) saveState();  // only save state *after* first render

      tx = ty = 0;
      tscale = 1;
      midX = cx;
      midY = cy;
      avgD = 0;
      gotPNG = false;
      done = false;
      if (wasm) {
        wasm.setupSize(width, height, maxIter, smooth,
                       xfocus, yfocus, dscale, jx, jy);
      }
    }
    function resetFocus() {
      xfocusBF = new BigFloat(!jx && !jy ? -0.75 : 0);
      yfocusBF = new BigFloat(0);
      radiusBF = new BigFloat(1.25);
      calcScale();
    }
    resetFocus();

    let cctable = null;
    let ctable = [];

    function makeColors() {
      let t = 2 * Math.PI / 256;
      let a = 0;
      // ctable index 0: 145 70 255 (#9146ff)
      const or = Math.asin((145-128)/127);
      const ob = Math.asin((255-128)/127);
      const og = Math.asin((70-128)/127);
      ctable = [];
      for (i = 0; i < maxIter; i++) {
        const r = Math.floor(128 + 127 * Math.sin(a*mr+or));
        const b = Math.floor(128 + 127 * Math.sin(a*mb+ob));
        const g = Math.floor(128 + 127 * Math.sin(a*mg+og));
        a += t;
        t *= Math.pow(0.90, (1 / (i/10+3)));
        if (grayscale) {
          const v = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);
          r = g = b = v;
        }
        if (cctable) {
          cctable[i] = r | (g << 8) | (b << 16) | 0xff000000;
        }
        ctable.push([r, g, b]);
      }
      ctable.push(ctable[0]);
      if (cctable) {
        cctable[i] = cctable[0]
      }
    }

    // BigFloat version of mandelbrot
    function mandelbrotBF(px, py, x0, y0, bits) {
      if (!bits) bits = 16;
      let x = new BigFloat(px - cx, bits);
      x.multiply(dscaleBF);
      x.multiply(xfocusBF);
      let y = new BigFloat(py - cy, bits);
      y.multiply(dscaleBF);
      y.multiply(yfocusBF);
      let xsq = new BigFloat(x, bits);
      xsq.multiply(x);
      let ysq = new BigFloat(y, bits);
      ysq.multiply(y);
      let i = 0;
      if (!x0 && !y0) {  // if these are non-zero, julia; else mandelbrot
        x0 = new BigFloat(x, bits);
        y0 = new BigFloat(y, bits);
      }
      let sum = new BigFloat(0, bits);
      let v256 = new BigFloat(256, bits);
      do {
        // y = 2 * x * y + y0;
        y.multiply(x);
        y.exponent++; // multiply 2;
        y.add(y0);
        // x = xsq - ysq + x0;
        x.assign(ysq);
        x.unaryMinus()
        x.add(xsq);
        x.add(x0);
        // xsq = x * x;
        xsq.assign(x);
        xsq.multiply(x);
        // ysq = y * y;
        ysq.assign(y);
        ysq.multiply(y);
        sum.assign(xsq);
        sum.add(ysq);
        i++;
      } while (i < maxIter && sum.lessThan(v256));
      if (smooth && i < maxIter - 2) {
        let fsum = Number(sum);
        i += 1-Math.log((0.5 * Math.log(fsum))/Math.LN2) / Math.LN2;
      }
      return i; 
    }


    function mandelbrot(px, py, x0, y0) {
      let x = (px - cx) * dscale + xfocus;
      let y = (py - cy) * dscale + yfocus;
      let xsq = x*x;
      let ysq = y*y;
      let i = 0;
      if (!x0 && !y0) {  // if these are non-zero, julia; else mandelbrot
        x0 = x;
        y0 = y;
      }
      do {
        y = 2 * x * y + y0;
        x = xsq - ysq + x0;
        xsq = x * x;
        ysq = y * y;
        i++;
      } while (i < maxIter && xsq + ysq <= 256);
      if (smooth && i < maxIter - 2) {
        i += 1-Math.log((0.5 * Math.log(xsq + ysq))/Math.log(2))/Math.log(2);
      }
      return i; 
    }

    function calcWork() {
      for (let work = 0; !done && work < workUnit; work++) {
        // calculate in spiral from center
        const x = cx + xpos;
        const y = cy + ypos;
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const o = y * width + x;
          const it = mandelbrotBF(x, y, jxBF, jyBF);
          //const it = mandelbrot(x, y, jx, jy);
          let i = Math.floor(it);
          if (smooth && i < maxIter) {
            let e = (i + 1) - it;
            if (i <= 0) i = e = 0;
            const f = 1 - e;
            const c1 = ctable[i];
            const c2 = ctable[i + 1];
            const o4 = o * 4;
            img.data[o4] = Math.floor(c1[0] * e + c2[0] * f);
            img.data[o4 + 1] = Math.floor(c1[1] * e + c2[1] * f);
            img.data[o4 + 2] = Math.floor(c1[2] * e + c2[2] * f);
            img.data[o4 + 3] = 255;
          } else {
            data32[o] = cctable[i]
          }
          px++;
        }
        if ((xpos == ypos) ||
            ((xpos < 0) && (xpos == -ypos)) ||
            ((xpos > 0) && (xpos == 1 - ypos))) {
          const dx = cdx;
          cdx = -cdy;
          cdy = dx;
        }
        xpos += cdx;
        ypos += cdy
      }
    }
    function saveState() {
      window.onhashchange = null;
      let hash=`x=${xfocusBF.toString(64)}&y=${yfocusBF.toString(64)}` +
               `&r=${radiusBF.toString(64)}`;
      const baseUrl = window.location.href.split('#')[0];
      if (jx) hash += `&jx=${jxBF.toString(64)}`;
      if (jy) hash += `&jy=${jyBF.toString(64)}`;
      if (mr != DEFAULT_MR) hash+=`&mr=${mr}`;
      if (mb != DEFAULT_MB) hash+=`&mb=${mb}`;
      if (mg != DEFAULT_MG) hash+=`&mg=${mg}`;
      if (maxIter != DEFAULT_I) hash+=`&i=${maxIter}`;
      if (grayscale != DEFAULT_G) hash+=`&g=${grayscale ? 1 : 0}`;
      if (smooth != DEFAULT_S) hash+=`&s=${smooth ? 1 : 0}`;
      if (!useWasm) hash+='&w=0';
      window.location.replace(baseUrl + '#' + hash);
      window.onhashchange = loadState;
    }
    function loadState() {
      const args = window.location.hash.substr(1).split('&');
      let x, y, r, i, s, g;
      // reset color multipliers that aren't specified in url
      mr = DEFAULT_MR;
      mb = DEFAULT_MB;
      mg = DEFAULT_MG;
      args.forEach(function(arg) {
        const v = arg.split('=');
        if (v.length < 2)
          return;
        const bf = new BigFloat(v[1]);
        const f = Number(bf);
        if (v[0] == "x") x = bf;
        if (v[0] == "y") y = bf;
        if (v[0] == "jx") jx = bf;
        if (v[0] == "jy") jy = bf;
        if (v[0] == "r") r = bf;
        if (v[0] == "mr") mr = f;
        if (v[0] == "mb") mb = f;
        if (v[0] == "mg") mg = f;
        if (v[0] == "i") i = f|0;
        if (v[0] == "s") s = f|0;
        if (v[0] == "g") g = f|0;
        if (v[0] == "w") useWasm = f|0;
      });
      // precision not needed to compare BigFloat with limits
      if (Number(x) > -4 && Number(x) < 4) xfocusBF = x;
      if (Number(y) > -4 && Number(y) < 4) yfocusBF = y;
      if (Number(r) > 0 && Number(r) <= 16) radiusBF = r;
      if (i > 63 && i < 1048576) maxIter = i;
      if (s == 0 || s > 0) smooth = (s > 0);
      if (g == 0 || g > 0) grayscale = (g > 0);
      calcScale();
      makeColors();
      saveState(); // remake the "canonical" url
    }
    loadState();
    function resizeCanvas() {
      const ow = canvas.width;
      const oh = canvas.height;
      const nw = window.innerWidth;
      const nh = window.innerHeight;
      const ncx = Math.floor(nw/2);
      const ncy = Math.floor(nh/2);
      tx = ty = 0;
      tscale = 1;
      done = true;
      if (img) {
        if (!gotPNG) {
          // get a png of current img data to scale into new img
          drawScaledImageData(img, 0, 0, 1);
        }
        const nr = (nh < nw ? nh : nw);
        const or = (oh < ow ? oh : ow);
        updateView(nw - ow, nh - oh, nr / or, ncx, ncy);
      }
      canvas.width = width = nw;
      canvas.height = height = nh;
      cx = ncx;
      cy = ncy

      if (wasmptr && wasm && (img == null || png == null ||
          img.width != width || img.height != height)) {
        const wasmdata = new Uint8ClampedArray(wasm.memory.buffer, wasmptr,
                               canvas.width * canvas.height * 4);
        data32 = new Uint32Array(wasm.memory.buffer, wasmptr, width * height);
        img = new ImageData(wasmdata, width, height);
        //data32.fill(cctable[0]);
        if (gotPNG) {
          // update new image with saved png at appropriate scale
          drawScaledImageData(img, tx, ty, tscale);
          ctx.putImageData(img, 0, 0);
          ctx.drawImage(png, tx, ty, ow * tscale, oh * tscale);
          getCurrentImageData();
        }
        png = new Image(canvas.width, canvas.height);
        if (gotPNG) {
          gotPNG = false;
          done = true;
          drawScaledImageData(img, 0, 0, 1);
        }
      }
      // if tscale/tx/ty updated, updates will happen in animate after
      // a half second timeout
      console.log(gotPNG, tx, ty, tscale);
      if (!gotPNG) calcScale();
    }

    let lasttime = 0;
    let lastmove = 0;
    let refresh = 1000/30;  // 30fps initial budget
    let mouseDown = null;
    let mouseMove = null;
    let mouseOver = null;
    let numTouches = 0;

    let lastMidX = 0;
    let lastMidY = 0;
    function updateView(dx, dy, ds, midX, midY) {
      lastmove = lasttime;
      // calculate new scale and position based on dx, dy, ds
      let sdx = (tx - midX) * ds + midX - tx;
      let sdy = (ty - midY) * ds + midY - ty;
      if (!(midX === undefined || midY === undefined)) {
        lastMidX = midX;
        lastMidY = midY;
      }
      let newTscale = tscale * ds;
      if (radius / newTscale > maxRadius) {
        newTscale = radius / maxRadius;
        const s = newTscale / tscale;
        sdx = (tx - midX) * s + midX - tx;
        sdy = (ty - midY) * s + midY - ty;
      }
      const newRadius = radius / newTscale;
      if (midX === undefined || midY === undefined) {
        sdx = sdy = 0;
      }
      let newTx = tx + dx + sdx;
      let newTy = ty + dy + sdy;
      const centerx = (newTx - cx) / tscale + cx;
      const centery = (newTy - cy) / tscale + cy;
      const newXfocus = xfocus - centerx * dscale;
      const newYfocus = yfocus - centery * dscale;
      // limit x,yfocus to no greater than radius 3 from origin
      const rsquared = newXfocus * newXfocus + newYfocus * newYfocus;
      const mRadius = (newRadius - 3 > 3 ? newRadius - 3 : 3);
      if (rsquared > mRadius * mRadius) {
        const d = Math.sqrt(rsquared);
        const ndx = newXfocus / d;
        const ndy = newYfocus / d;
        newTx += (newXfocus - ndx * mRadius) / dscale;
        newTy += (newYfocus - ndy * mRadius) / dscale;
      }
      // commit valid view
      tx = newTx;
      ty = newTy;
      tscale = newTscale;
    }
    function calcView() {
      // calculate new scale based on last tx, ty, tscale
      let centerx = new BigFloat((tx - cx) / tscale + cx);
      let centery = new BigFloat((ty - cy) / tscale + cy);
      centerx.multiply(dscaleBF);
      centery.multiply(dscaleBF);
      xfocusBF.sub(centerx);
      yfocusBF.sub(centery);
      let ts = new BigFloat(tscale);
      radiusBF.divide(ts);
      drawScaledImageData(img, tx, ty, tscale);
      getCurrentImageData();
      calcScale();
    }
    // handle touch events:
    // find average point of all active touches
    // find average distance from midpoint to active touches
    // for touchmove events only:
    //   tx += last midpoint midX - current midpoint x
    //   ty += last midpoint midY - current midpoint y
    //   update midX, midY to current average midpoint
    //   tscale *= last average distance (avgD) / current average distance
    //   update avgD to current average distance
    // for touchstart/touchend only:
    //   update midX, midY, avgD; no change in tscale or tx, ty
    function touchEvent(event) {
      event.preventDefault();
      done = true;  // stop work if user is interacting
      numTouches = event.touches.length;
      let curMidX = 0, curMidY = 0, curAvgD = 0;
      if (event.touches.length > 0) {
        for (let i = 0; i < numTouches; i++) {
          curMidX += event.touches[i].clientX;
          curMidY += event.touches[i].clientY;
        }
        curMidX /= numTouches;
        curMidY /= numTouches;
        for (let i = 0; i < numTouches; i++) {
          const dx = event.touches[i].clientX - midX;
          const dy = event.touches[i].clientY - midY;
          const d = Math.sqrt(dx * dx + dy * dy);
          curAvgD += d;
        }
        curAvgD /= numTouches;
      }

      if (event.type == "touchend" && !event.touches.length) {
        calcView();
        return;
      }
      if (event.type == "touchcancel") {
        tx = 0;
        ty = 0;
        midX = cx;
        midY = cy;
        tscale = 1;
        avgD = 0;
      }
      if (event.type == "touchmove") {
        updateView(curMidX - midX, curMidY - midY, 1);
        if (numTouches > 1) {
          updateView(0, 0, curAvgD / avgD, curMidX, curMidY);
        }
      }
      midX = curMidX;
      midY = curMidY;
      avgD = curAvgD;
    }
    function mouseWheel(event) {
      event.preventDefault();
      done = true;  // stop work if user is interacting
      const x = event.clientX;
      const y = event.clientY;
      let s = 1;
      if (event.ctrlKey) {  // touchpad pinch
        s = Math.exp(-event.deltaY/20);
      } else {  // scrollwheel
        s = Math.exp(-event.deltaY / 200);
      }
      updateView(0, 0, s, x, y);
    }
    function mouseEvent(event) {
      event.preventDefault();
      if (event.type == "mouseleave") {
        mouseDown = null;
        mouseMove = null;
        return;
      }
      if (event.type == "mousedown") {
        done = true;  // stop work if user is interacting
        mouseDown = event;
      } else if (event.type == "mousemove") {
        mouseMove = event;
        if (mouseDown)
          updateView(event.movementX, event.movementY, 1);
      } else {
        mouseDown = null;
      }
    }
    function centerText(text, y) {
      const t = ctx.measureText(text);
      ctx.fillText(text, cx - t.width/2, y);
      return t.width/2;
    }
    function animate(timestamp) {
	const dt = timestamp - lasttime;
	lasttime = timestamp;
        const pct = Math.floor(100*px/pxtot);
        drawScaledImageData(img, tx, ty, tscale);
        ctx.fillStyle = 'rgba(0,0,0,0.33)';
        ctx.fillRect(0,canvas.height-48,canvas.width, 48);
        ctx.fillStyle = '#f00';
        if (pct < 100) {
          ctx.fillRect(0,canvas.height-48,canvas.width, 5);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(0,canvas.height-48,canvas.width * pct / 100, 5);
        }
        const msb = dscaleBF.exponent + dscaleBF.msb;
        ctx.fillStyle = (msb > -51 ? '#fff' : '#f77');
        ctx.font = '14px Roboto Mono';
        if (jx || jy) {
          centerText(`jx=${jxBF.toString()}   ` +
                     `jy=${jyBF.toString()}`, canvas.height - 32);
        }
        ctx.fillText(msb, cx + centerText(
                `x=${xfocusBF.toString()}   ` +
                `y=${yfocusBF.toString()}   ` +
                `r=${radiusBF.toString()}   2`, canvas.height - 18),
                canvas.height - 28);
        if (mouseMove) {
          const xm = (mouseMove.clientX - cx) * dscale + xfocus;
          const ym = (mouseMove.clientY - cy) * dscale + yfocus;
          centerText(`x=${xm.toExponential(16)}   ` +
                     `y=${ym.toExponential(16)}`, canvas.height - 3);
        }

        const c = [
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/7)),
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/3)),
          128 + Math.floor(127 * Math.sin(0.07 * timestamp/5))
        ];
        ctx.strokeStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
        ctx.fillStyle = `rgb(${c[1]},${c[2]},${c[0]})`;
        if (tx || ty || tscale != 1) {
          const x = (-xfocus / dscale + cx) * tscale + tx;
          const y = (-yfocus / dscale + cy) * tscale + ty;
          const rm = (cx < cy ? 0.5 * cx : 0.5 * cy);
          const cscale = tscale * Math.pow(2, -Math.log2(tscale) - 2);
          const r1 = (10 * cscale);
          const r2 = (2 * rm * cscale);
          ctx.fillText(tscale, lastMidX, lastMidY);
          ctx.beginPath();
          ctx.arc(lastMidX, lastMidY, r1, 0, 2 * Math.PI);
          ctx.arc(lastMidX, lastMidY, r2, 0, 2 * Math.PI);
          ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy);
          ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10);
          ctx.moveTo(x - 10, y - 10); ctx.lineTo(x + 10, y + 10);
          ctx.moveTo(x - 10, y + 10); ctx.lineTo(x + 10, y - 10);
          ctx.stroke();
          if (!mouseDown && !numTouches) {
            // update pending view change if a half second has passed
            if (lasttime - lastmove > 555)
              calcView();
          }
        }
        if (!done) {
          if (useWasm && wasm) {
            px = wasm.calcWork(workUnit);
          } else {
            calcWork();
          }
          done = (px >= pxtot);
        }
        // ctrl key switches to julia view at mouse position
        if (mouseMove && !mouseDown && mouseMove.ctrlKey) {
          const x0 = (mouseMove.clientX - cx) * dscale + xfocus;
          const y0 = (mouseMove.clientY - cy) * dscale + yfocus;
          if (jx != x0 && jy != y0) {
            jxBF = new BigFloat(x0); jyBF = new BigFloat(y0);
            calcScale();
          }
        }
        // alt key switches back to mandelbrot view at mouse position
        if (mouseMove && !mouseDown && mouseMove.altKey) {
          if (jx || jy) {
            jxBF = new BigFloat(0); jyBF = new BigFloat(0);
            calcScale();
          }
        }
        // shift key shows escape at mouse position
        if (mouseMove && !mouseDown && mouseMove.shiftKey) {
          ctx.save();
          ctx.translate(tx, ty);
          ctx.scale(tscale, tscale);
          ctx.strokeStyle = '#ffd';
          let xPt = mouseMove.clientX;
          let yPt = mouseMove.clientY;
          let x = (xPt - cx) * dscale + xfocus;
          let y = (yPt - cy) * dscale + yfocus;
          let i = 0;
          const j = !(!jx && !jy)
          const x0 = (j ? jx : x);
          const y0 = (j ? jy : y);
          const pscale = 1 / dscale;
          ctx.beginPath();
          ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(xPt, yPt);
          let xsq = x*x;
          let ysq = y*y;
          do {
            xPt = (x - xfocus) * pscale + cx;
            yPt = (y - yfocus) * pscale + cy;
            ctx.lineTo(xPt, yPt)
            ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
            y = 2 * x * y + y0;
            x = xsq - ysq + x0;
            xsq = x * x;
            ysq = y * y;
            i++;
          } while (i < 256 && xsq + ysq <= 65536);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(xPt, yPt, 3, 0, 2 * Math.PI);
          ctx.fill();
          // show fractional scale around main cardioid
          const tsz = 0.035 / dscale;
          const sz = tsz > 24 ? 24 : tsz;
          ctx.font = `${sz}px Roboto Mono`;
          // generate 60 fractional points around the main cardioid
          if (!fracscale.length) {
            let fr = [], frNext = [];
            for (let i = 1; i < 14; i++) { frNext.push({ n: 1, d:i}); }
            fr.push(frNext.pop());
            while (frNext.length > 0) {
              let next = frNext[frNext.length - 1];
              let last = fr[fr.length - 1];
              if (next.d + last.d < 14) {
                frNext.push({ n: next.n + last.n, d: next.d + last.d });
              } else {
                fr.push(frNext.pop());
              }
            };
            // generate cardioid with points from above fractions
            fr.forEach(function(f) {
              const t = f.n * 2 * Math.PI / f.d;
              // graph r = 1 - cos(t)
              const st = Math.sin(t);
              const ct = Math.cos(t);
              x = .5 * ct - .5 * ct * ct + 0.25;
              y = .5 * st - .5 * ct * st;
              let txt = null;
              let ta = 0;
              if (!(f.n == 1 && f.d == 1)) {
                let r = 0;
                if (f.n/f.d > 1/3 && f.n / f.d <=  2/3)
                  r += Math.PI;
                ta = Math.atan(-1/Math.tan(3 * t / 2)) + r;
                txt = `${f.n}/${f.d}`;
              }
              fracscale.push({ x: x, y: y, t: t, ta: ta, txt: txt });
            });
          }
          ctx.strokeStyle = '#fdf';
          ctx.fillStyle = '#fdf';
          ctx.beginPath();
          // draw crosshairs at 0, 0
          x = -xfocus * pscale + cx; y = -yfocus * pscale + cy;
          ctx.moveTo(x - sz, y); ctx.lineTo(x + sz, y);
          ctx.moveTo(x, y - sz); ctx.lineTo(x, y + sz);
          if (!jx && !jy) {
            let ox = x, oy = y;
            fracscale.forEach(function(e, i) {
              x = (e.x - xfocus) * pscale + cx;
              y = (e.y - yfocus) * pscale + cy;
              if (!i) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
              let dx = x - ox;
              let dy = y - oy;
              if (e.txt && dx * dx + dy * dy > sz * sz + 4) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(e.ta);
                ctx.fillRect(-0.5 * sz, 0, 0.7 * sz, 0.1 * sz);
                ctx.fillText(e.txt, -3.5*sz, 0.5 * sz);
                ctx.restore();
                ox = x; oy = y;
              }
            });
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }

        if (dt < refresh || done) {
            refresh = dt;
        }
        // adjust work unit size to match available time budget
        if (!done) {
          refresh += 1; // relax threshold to point of correction
          if (dt > refresh && workUnit > 1) {
            workUnit = Math.floor(workUnit * 0.75);
          } else {
            workUnit += Math.floor(1048576 / maxIter);
          }
        }
	requestAnimationFrame(animate);
        wasmConsole();
    }

    const pfft = {passive:false};
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('mouseup', mouseEvent, pfft);
    canvas.addEventListener('mousedown', mouseEvent, pfft);
    canvas.addEventListener('mousemove', mouseEvent, pfft);
    canvas.addEventListener('mouseleave', mouseEvent, pfft);
    canvas.addEventListener('wheel', mouseWheel, pfft);
    canvas.addEventListener('scroll', mouseWheel, pfft);
    canvas.addEventListener('touchstart', touchEvent, pfft);
    canvas.addEventListener('touchend', touchEvent, pfft);
    canvas.addEventListener('touchmove', touchEvent, pfft);
    canvas.addEventListener('touchcancel', touchEvent, pfft);

    const decode = (b64) => {
      const a = Uint8Array.from(atob(base64wasm), c => c.charCodeAt(0));
      return a.buffer;
    };

    WebAssembly.instantiate(new Uint8Array(decode(base64wasm))
    ).then(result => {
      wasm = result.instance.exports;
      wasmptr = wasm.init(maxCanvas);  // setup max expected size
      cctable = new Uint32Array(wasm.memory.buffer, wasm.ctable, 1048576);
      makeColors();
      resizeCanvas();
      window.requestAnimationFrame(animate);
    });

 </script>

</body>
</html>
