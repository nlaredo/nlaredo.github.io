<!doctype html>
<html>
<head>
  <title>PlayMIDI</title>
  <meta charset=utf-8 />
  <meta name="copyright" content="Nathan Laredo" />
  <meta name="author" content="Nathan Laredo" />
  <style>
    body,html,canvas { border:0; margin:0; padding:0; overflow:hidden;
      font-family:sans-serif; }
    canvas { background:#007; }
    #config {
      position:fixed; top:75px; right:25px; left:25px;
      border:3px solid #ccd; background:#00007777; color:#ccd;
      padding:25px; font:1em sans-serif; overflow-y:auto;
      bottom: 76px;
    }
    .ccontainer {
      display:grid;
      grid-template-rows: repeat(4, 2em);
      grid-template-columns: repeat(4, 1fr);
      grid-auto-flow: column;
    }
    .container2 {
      display:grid;
      grid-template-rows: repeat(9, 2em);
      grid-template-columns: repeat(2, 1fr);
      grid-auto-flow: column;
    }
    li { padding:2px; }
    li:nth-child(even) { background:#0007; }
    a { text-decoration:none }
    a:link { color:#ff4; }
    a:visited { color:#f44; }
    a:hover { text-decoration:underline; }
    a:active { background:#f44; color:#ffe; }
    h1,h2,h3,h4,p { text-align: center }
    input { width:4em; }
    span { display:inline-block; width:5em; }
    select { width:11em; }
    label,input { margin:1px; }
    #license { position:fixed; top:75px; left:25px;
      color:#00f; padding:25px; font-size:70%; }
    #license a { color:#00f; }
    .ccontainer div { margin:auto; width:8em; padding:1px; }
    .container2 div { margin:auto; width:16em; padding:1px; }
    input[type=button],input[type=submit] {
      background: #ccd; width:8em; height:2em;
    }
    input[type=file] { width:24em; }
    .active { background:#070; }
    #transport {
      position:fixed; bottom:0px; left:0px; right:0px;
      background:#000; color:#ccd; max-height:128px;
      min-height:32px;
    }
    #transport input { height:32px; width:76px; }
  </style>
</head>
<body>
<pre id="license">
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <a
href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</pre>
<canvas id="keyboard"></canvas>
<div id="config">
<h1>PlayMIDI Settings</h1>
<h4>v20190821 -- Follow development at:
<a href="http://twitch.tv/nil4k">twitch.tv/nil4k</a>
and <a href="http://github.com/nlaredo">GitHub</a>
and <a href="http://youtube.com/NathanILaredo">YouTube</a></h4>
<p>Tap or click the area above this window to open this config window
while playing...</p>
<p>Play multiple midi files by drag &amp; drop
in this browser window or by the file dialog at the bottom of
the settings.</p>
<form id="cfgform" action="#">
<p><input type="submit" value="Dismiss"></p>
<div class="container2">
<div><label><input name="soundon" type="checkbox" value="soundon"
checked> Generate Sounds</input></label></div>
<div><label><input name="showflames" type="checkbox" value="showflames">
Generate Flames</input></label></div>
<div><label><input name="showfountain" type="checkbox"
value="showfountain"> Bellagio Fountain</input></label></div>
<div><label><input name="showdebug" type="checkbox" value="showdebug">
Show Debug Info</input></label></div>
<div><label><input name="showoctaves" type="checkbox" value="showoctaves"
defaultChecked="false"> Show Octave Lines</input></label></div>
<div><label><input name="mastertune" type="number" value="440"
min="415.3" max="466.2" step="any"> Master Tuning</input></label></div>
<div><span>MIDI in:</span><select
name="midiin"><option value="none">none</option></select></div>
<div><span>MIDI out:</span><select
name="midiout"><option value="none">none</option></select></div>
<div><span>MIDI ctrl:</span><select
name="midictrl"><option value="none">none</option></select></div>
<div><label><input name="bendup" type="number"
value="2" min="1" max="24"> Pitch Bend Pos</input></label></div>
<div><label><input name="benddn" type="number"
value="-12" min="-24" max="-1"> Pitch Bend Neg</input></label></div>
<div><label><input name="touchchan" type="number" value="2"
min="1" max="16"> Touch Event Channel</input></label></div>
<div><label><input name="mousechan" type="number" value="3"
min="1" max="16"> Mouse Event Channel</input></label></div>
<div><label><input name="keychan" type="number" value="6"
min="1" max="16"> PC Key Event Channel</input></label></div>
<div><label><input name="keyalpha" type="number" value="1"
min="0" max="1" step="any"> Key Alpha (visibility)</input></label></div>
<div><label><input name="keyshadow" type="checkbox" value="keyshadow"
defaultChecked="false"> Shadow Overload</input></label></div>
<div><label><input name="showspect" type="checkbox" value="showspect"
defaultChecked="false"> Show Spectogram</input></label></div>
<div><label><input name="psize" type="number" value="3"
min="1" max="9" step="any"> Particle Size (pixels)</input></label></div>
</div>
<h4>MIDI Channel Colors</h4>
<div class="ccontainer">
<div><label><input name="c1" type="color" value="#ff0000">
Ch 1</input></label></div>
<div><label><input name="c2" type="color" value="#0000ff">
Ch 2</input></label></div>
<div><label><input name="c3" type="color" value="#ff00ff">
Ch 3</input></label></div>
<div><label><input name="c4" type="color" value="#00ff00">
Ch 4</input></label></div>
<div><label><input name="c5" type="color" value="#ffff00">
Ch 5</input></label></div>
<div><label><input name="c6" type="color" value="#00ffff">
Ch 6</input></label></div>
<div><label><input name="c7" type="color" value="#ff0000">
Ch 7</input></label></div>
<div><label><input name="c8" type="color" value="#3f00c0">
Ch 8</input></label></div>
<div><label><input name="c9" type="color" value="#ff00c0">
Ch 9</input></label></div>
<div><label><input name="c10" type="color" value="#3fc000">
Ch 10</input></label></div>
<div><label><input name="c11" type="color" value="#ffc000">
Ch 11</input></label></div>
<div><label><input name="c12" type="color" value="#3fc0c0">
Ch 12</input></label></div>
<div><label><input name="c13" type="color" value="#803f00">
Ch 13</input></label></div>
<div><label><input name="c14" type="color" value="#003f80">
Ch 14</input></label></div>
<div><label><input name="c15" type="color" value="#803f80">
Ch 15</input></label></div>
<div><label><input name="c16" type="color" value="#008000">
Ch 16</input></label></div>
</div>
<p><input name="default" type="button" value="Reset Colors"
 onclick="makeccolor()" /></p>
<br><input id="upload" type="file" multiple
accept=".mid,.kar,.midi" onchange="handlefiles(this.files)" /></br>
<div id="filequeue"><ul><li>No files queued.</li></ul></div>
</input>
</form>
</div>
<div id="transport">
<input name="default" type="button" value="Prev"></input>
<input name="default" type="button" value="Pause"></input>
<input name="default" type="button" value="Play"></input>
<input name="default" type="button" value="Next"></input>
<input name="default" type="button" value="Loop"></input>
<input name="default" type="button" value="Loop Start"></input>
<input name="default" type="button" value="Loop End"></input>
<input name="default" type="button" value="Tap" id="tap"></input>
<label>Tempo:<input id="tempo" name="tempo" type="number" value="120"
min="1" max="500" step="any"></input></label>
</div>
<script type="text/javascript">
//<![CDATA[
var license = document.getElementById("license");
var canvas = document.getElementById("keyboard");
var config = document.getElementById("config");
var cfgform = document.forms['cfgform'];
var filequeue = document.getElementById("filequeue");
var transport = document.getElementById("transport");
var settempo = document.getElementById("tempo");
var taptempo = document.getElementById("tap");
var filelist = [];
var ctx = canvas.getContext("2d");

var context=null;	// the Web Audio "context" object
var midiAccess=null;	// the MIDIAccess object.
var voice = [];         // tracking of synth voices
var lfo;                // for tracking synth LFO
var lfout;              // for drawing LFO data
var lfdata;
var fftout;             // for drawing FFT data
var fftdata;
var mastervol;          // master gain control
var moddepth = 50;      // mod depth range in cents (midi default 50 cents)
var modoff = 0;         // fractional note offset for visual modwheel
var attack=0.01;	// attack speed
var decay=0.05;	        // decay speed
var sustain=0.75;       // sustain level
var release=0.15;	// release speed
var mastertune=440;
var maxVoices=16;
var soundon = false;
var hold1 = false;      // cc64
var sostenuto = false;  // cc66
var sostenutolist = []; // notes on at the time sostenuto pressed
var soft = false;       // cc67
var showoctaves = false;
var showflames = false;
var showfountain = false;
var showdebug = false;
var showconfig = true;
var showspect = false;

var mididata = [];
var midiinputs = [{ id:null, name:'midi disabled', type:'error' }];
var midioutputs = [{ id:null, name:'midi disabled', type:'error' }];
var midiout = null;  // id of selected out device or null for none
var midiin = null;   // id of selected in device or null for none
var midictrl = null;   // id of selected in device or null for none
// a bunch of midi constants to avoid magic numbers...
var smf_meta_events = {
  SEQUENCE_NUMBER:0x00,
  TEXT_EVENT:0x01,
  COPYRIGHT_NOTICE:0x02,
  SEQUENCE_NAME:0x03,
  INSTRUMENT_NAME:0x04,
  LYRIC:0x05,
  MARKER:0x06,
  CUE_POINT:0x07,
  PROGRAM_NAME:0x08,
  DEVICE_NAME:0x09,
  CHANNEL_PREFIX:0x20,
  END_OF_TRACK:0x2f,
  SET_TEMPO:0x51,
  SMPTE_OFFSET:0x54,
  TIME_SIGNATURE:0x58,
  KEY_SIGNATURE:0x59,
  SEQUENCER_SPECIFIC:0x74,
  META_EVENT:0xff, // prefixes all of the above in the midi file
};
var midi_status = {
  NOTEOFF:0x80,
  NOTEON:0x90,
  KEY_PRESSURE:0xa0,
  CTL_CHANGE:0xb0,
  PGM_CHANGE:0xc0,
  CHN_PRESSURE:0xd0,
  PITCH_BEND:0xe0,
  SYSTEM_PREFIX:0xf0,
};
var midi_sys = {
  SYSTEM_EXCLUSIVE:0xf0,
  TIME_CODE_QF:0xf1,
  SONG_POSITION:0xf2,
  SONG_SELECT:0xf3,
  TUNE_REQUEST:0xf6,
  SYSEX_END:0xf7,
  TIMING_CLOCK:0xf8,
  START:0xfa,
  CONTINUNE:0xfb,
  STOP:0xfc,
  ACTIVE_SENSING:0xfe,
  RESET:0xff,
};
var midi_ctl = {
  BANK_SELECT:0x00,
  MODWHEEL:0x01,
  BREATH:0x02,
  LFO_RATE:0x03,
  FOOT:0x04,
  PORTAMENTO_TIME:0x05,
  DATA_ENTRY:0x06,
  MAIN_VOLUME:0x07,
  BALANCE:0x08,
  PAN:0x0a,
  EXPRESSION:0x0b,
  MOTIONAL_CTL1:0x0c,
  MOTIONAL_CTL2:0x0d,
  MOTIONAL_CTL3:0x0e,
  GEN_PURPOSE1:0x10,
  TONE_MODIFY1:0x10,
  GEN_PURPOSE2:0x11,
  TONE_MODIFY2:0x11,
  GEN_PURPOSE3:0x12,
  GEN_PURPOSE4:0x13,
  MOTIONAL_EXT1:0x1c,
  MOTIONAL_EXT2:0x1d,
  MOTIONAL_EXT3:0x1e,
  LSB:0x20,  // all above have LSB at above value + 0x20
  DAMPER_PEDAL:0x40,
  SUSTAIN:0x40,
  HOLD:0x40,
  HOLD1:0x40,
  PORTAMENTO:0x41,
  SOSTENUTO:0x42,
  SOFT_PEDAL:0x43,
  LEGATO:0x44,
  HOLD2:0x45,
  // controllers 70-79 are *not* reset on "reset all controllers"
  SOUND_VARIATION:0x46,
  RESONANCE:0x47,
  RELEASE_TIME:0x48,
  ATTACK_TIME:0x49,
  CUTOFF:0x4a,
  BRIGHTNESS:0x4a,
  DECAY_TIME:0x4b,
  VIBRATO_RATE:0x4c,
  VIBRATO_DEPTH:0x4d,
  VIBRATO_DELAY:0x4e,
  SOUND_CONTROLLER10:0x4f,
  GEN_PURPOSE5:0x50,
  TONE_VARIATION1:0x50,
  GEN_PURPOSE6:0x51,
  TONE_VARIATION2:0x51,
  GEN_PURPOSE7:0x52,
  TONE_VARIATION3:0x52,
  GEN_PURPOSE8:0x53,
  TONE_VARIATION4:0x53,
  PORTAMENTO_CTRL:0x54,
  VELOCITY_LSB:0x58,
  // controllers 91 - 95 are *not* reset on "reset all controllers"
  REVERB_DEPTH:0x5b,
  TREMOLO_DEPTH:0x5e,
  CELESTE_DEDPTH:0x5e,
  CHORUS_DEPTH:0x5f,
  DATA_INCREMENT:0x60,
  DATA_DECREMENT:0x61,
  NRPN_LSB:0x62,
  NRPN_MSB:0x63,
  RPN_LSB:0x64,
  RPN_MSB:0x65,
  ALL_SOUNDS_OFF:0x78,
  RESET_ALL_CONTROLLERS:0x79, // third byte 0
  LOCAL:0x7a,
  ALL_NOTES_OFF:0x7b,
  OMNI_OFF:0x7c,
  OMNI_ON:0x7d,
  MONO:0x7e,
  POLY:0x7f,
};

var midi_rpn = {
  PITCH_BEND_RANGE:0x00,  // mm = semitones, ll = cents, default=mm=2 
  // old: master fine is adjusted, new gm2: only channel fine is adjusted
  CHN_FINE_TUNE:0x01,  // -8192*50/8192 - 0 - +8192*50/8192 cent
  CHN_COARSE_TUNE:0x02,  // -48 - 0 - +48 semitones, ll = ignored
  TUNING_PGM_SEL:0x03,
  TUNING_BANK_SEL:0x04,
  MOD_DEPTH_RANGE:0x05,
  AZIMUTH_ANGLE:0x3d00,
  ELEVATION_ANGLE:0x3d01,
  GAIN:0x3d02,
  DISTANCE_RATIO:0x3d03,
  MAX_DISTANCE:0x3d04,
  GAIN_AT_MAX_DISTANCE:0x3d05,
  REF_DISTANCE_RATIO:0x3d06,
  PAN_SPREAD_ANGLE:0x3d07,
  ROLL_ANGLE:0x3d08,
  RPN_NULL:0x7f7f,
};

var midi_nrpn = {
  GS_VIBRATO_RATE:0x0108,  // -64 - 0(0x40) - +63 (relative)
  GS_VIBRATO_DEPTH:0x0109,  // -64 - 0(0x40) - +63 (relative)
  GS_VIBRATO_DELAY:0x010a,  // -64 - 0(0x40) - +63 (relative)
  // TVF = Time Variant Filter
  GS_TVF_CUTOFF_FREQ:0x0120,  // -64 - 0(0x40) - +63 (relative)
  GS_TVF_RESONANCE:0x0121,  // -64 - 0(0x40) - +63 (relative)
  // TVA = Time Variant Amplifier
  GS_TVFTVA_ATTACK:0x0163,  // -64 - 0(0x40) - +63 (relative)
  GS_TVFTVA_DECAY:0x0164,  // -64 - 0(0x40) - +63 (relative)
  GS_TVFTVA_RELEASE:0x0166,  // -64 - 0(0x40) - +63 (relative)
  GS_RHYTHM_PITCH_C:0x1800,  // 0x18rr rr = note number (abs)
  GS_RHYTHM_TVA_LVL:0x1a00,  // 0x1arr rr = note number (abs)
  // note: panpot -64 = "random", -63(L) - 0(Center) - +63(R)
  NRPN_GS_RHYTHM_PANPOT:0x1c00,  // 0x1crr rr = note number (abs)
  NRPN_GS_RHYTHM_REVERB:0x1d00,  // 0x1drr rr = note number (abs)
  NRPN_GS_RHYTHM_CHORUS:0x1e00,  // 0x1err rr = note number (abs)
  NRPN_NULL:0x7f7f,
};

// make all the enum-like objects read-only
if (Object.freeze) {
  Object.freeze(smf_meta_events);
  Object.freeze(midi_status);
  Object.freeze(midi_sys);
  Object.freeze(midi_ctl);
  Object.freeze(midi_rpn);
  Object.freeze(midi_nrpn);
}

var ccolor = [];
function hexrgb(r,g,b) {
  return "#" + ("0" + r.toString(16)).slice(-2) +
    ("0" + g.toString(16)).slice(-2) +
    ("0" + b.toString(16)).slice(-2);
}
// try to make 16 visually distinct colors, no black, no white
function makeccolor() {
  var c = 0;
  ccolor = [];
  // make default color table
  for (var i = 1; c < 16; i++) {
    if ((i & 7) == 0 || (i & 7) == 7)
      continue; // skip black and white
    var b3 = (i & 8) ? 63 : 0;
    var b4 = (i & 16) ? 127 : 0;
    var r = (i & 1) ? 255 - b4 : b3; 
    var g = (i & 2) ? 255 - b3 - b4 : (i & 16) ? 63 : 0;
    var b = (i & 4) ? 255 - b3 - b4 : (i & 16) ? 63 : 0;
    var color = hexrgb(r,g,b);
    ccolor.push(color);
    // update form color selector
    c++;
    cfgform["c" + c].value = color;
  }
}
makeccolor();
var touchchan = 1;
var mousechan = 2;
var keychan = 5;

var noteboxes = [];
var keyboxes = [];
var particles = [];
var maxparticles = 2000;
var psize = 3;
var gravity = 0.6;
var midilog = [];  // log for all generated/received events
var notefrac = 0;  // for tracking pitchbend
var bendmult = 1;  // for playing pitchbend
var bendup = 2;  // pitchbend range in semitones
var benddn = 12;  // pitchbend range in semitones
var keybed = 69.81818182; // 128 key full size midi keyboard in inches
var keydepth = 6; // depth in inches, always 6 for full size keys
var bkeydepth = 3.5; // black key depth in inches, 3.5 for full size keys
var keyscale = 0.0;  // allow resizing of keyboard, 0.0 = scale to 88
var keypan = 0;  // allow touch interface panning of the keyboard
var keyalpha = 1; // allow making the keys disappear for streaming
var keyshadow = false; // option to go crazy with context shadows
var kct = 128; // note: 68.818 inches for 128 keys, given 48 for 88
var bw;  // black key width in pixels
var kh;  // keyboard height in pixels
var bkh; // black key height in pixels
var dy;  // pixels to move up per animation frame
var th = 32;  // transport area height
var dw = canvas.width;  // drawing area height
var dh = canvas.height - th;  // drawing area width
var blackimg = null;
var whiteimg = null;
var noiseimg = null;
var fireimg1 = null;
var fireimg2 = null;

var whitekey = new Image();
var blackkey = new Image();
canvas.crossOrigin = null;
blackkey.crossOrigin = null;
whitekey.crossOrigin = null;
blackkey.onload = function () { blackimg = blackkey; };
blackkey.src = "images/blackkey.png";
whitekey.onload = function () { whiteimg = whitekey; };
whitekey.src = "images/whitekey.png";

resize();
initaudio();
function loadmidi(midifile) {
  this.index = filelist.length - 1;
  this.p = midifile.arrayBuffer().then(a => {
    filelist[this.index].buf = new Uint8Array(a);
    if (filelist[this.index].buf[0] != 0x4d ||
        filelist[this.index].buf[1] != 0x54 ||
        filelist[this.index].buf[2] != 0x68 ||
        filelist[this.index].buf[3] != 0x64) {
      filelist[this.index].ignore = true;
    }

    updatefilelist();
  });
}
function handlefiles(files) {
  var count = files.length;
  for (var i=0; i < count; i++) {
    filelist.push({
      buf:null,
      name:files[i].name,
      size:files[i].size,
      ignore:false,
      fillbuf:null,
    });
    // for promise: need to do this one *after* array push
    filelist[filelist.length-1].fillbuf = new loadmidi(files[i]);
  }
}
function updatefilelist() {
  var newhtml = '<ol>';
  count = filelist.length;
  for (var i=0; i < count; i++) {
    newhtml += '<li>' + filelist[i].name + ', ' + filelist[i].size +
      ' bytes ' + (filelist[i].buf ? 'loaded' : '') +
      (filelist[i].ignore ? ', ignored, not midi' : '') + '</li>';
  }
  newhtml += '</ol>';
  filequeue.innerHTML = newhtml;
}
function dragevent(event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.type == 'dragenter' || event.type == 'dragover') {
    canvas.classList.add('active');
    event.dataTransfer.dropEffect='copy';
  } else if (event.type == 'dragleave' || event.type == 'drop') {
    canvas.classList.remove('active');
    if (event.type == 'drop') {
      handlefiles(event.dataTransfer.files);
    }
  }
}
function enableevents() {
  // register some event handlers
  window.addEventListener('resize', resize, false);
  cfgform.addEventListener('submit', toggleconfig, false);
  var opt = {passive:false};
  window.addEventListener('keydown', keydown, opt);
  window.addEventListener('keyup', keyup, opt);
  window.addEventListener('contextmenu', mouseup, opt);
  canvas.addEventListener('mouseup', mouseup, opt);
  canvas.addEventListener('mousedown', mousedown, opt);
  canvas.addEventListener('mousemove', mousemove, opt);
  canvas.addEventListener('wheel', mousewheel, opt);
  canvas.addEventListener('touchstart', handletouch, opt);
  canvas.addEventListener('touchend', handletouch, opt);
  canvas.addEventListener('touchmove', handletouch, opt);
  canvas.addEventListener('touchcancel', handletouch, opt);
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(
    function(e) { window.addEventListener(e, dragevent, false); });
  // enable midi events
  if (navigator.requestMIDIAccess)
    navigator.requestMIDIAccess().then(gotMIDI, deniedMIDI);
}
// start animation behind menu
requestAnimationFrame(animate);
enableevents();
function failaudio() { soundon = false; }
function startaudio() {
  setSound(cfgform.soundon.checked);
  if (lfo.start < 0) {
    lfo.osc.start();
    lfo.start = 0;
  }
}
function toggleconfig(event) {
  // prevent form submit
  if (event) event.preventDefault();
  if (context.state == 'suspended') {
    if (event.type == 'submit' || event.type == 'contextmenu' ||
      event.type == 'mouseup' || event.type == 'touchend') {
      // resume audio context on "activation" interaction
      context.resume().then(startaudio,failaudio);
    } else
      return false; // prevent dismiss/submit
  }
  if (showconfig && !cfgform.checkValidity()) {
    cfgform.reportValidity();
    return false;  // prevent dismiss/submit
  }
  if (showconfig) {
    // validated form user is asking to dismiss
    setSound(cfgform.soundon.checked);
    showdebug = cfgform.showdebug.checked;
    showoctaves = cfgform.showoctaves.checked;
    mastertune = cfgform.mastertune.value;
    benddn = -cfgform.benddn.value;
    bendup = cfgform.bendup.value;
    touchchan = cfgform.touchchan.value - 1;
    mousechan = cfgform.mousechan.value - 1;
    keychan = cfgform.keychan.value - 1;
    keyalpha = cfgform.keyalpha.value;
    psize = cfgform.psize.value;
    keyshadow = cfgform.keyshadow.checked;
    for (var i = 0; i < 15; i++) {
      ccolor[i] = cfgform["c"+(i+1)].value;
    }
    showfountain = cfgform.showfountain.checked;
    showflames = cfgform.showflames.checked;
    showspect = cfgform.showspect.checked;
    midiin = cfgform.midiin.value;
    midiout = cfgform.midiout.value;
    midictrl = cfgform.midictrl.value;
    if (showflames)
      resize();
  }
  showconfig = !showconfig;
  config.style.display = showconfig ? 'block' : 'none';
  license.style.display = 'none';
  return false;  // prevent form submit
}
function dbRatio(dB) {
  if (dB < 0)
    return Math.pow(10, dB / 20);
  return 1.0-Math.pow(10, -dB / 20);
}
function setSound(value) {
  if (soundon == value)
    return;
  soundon = value;
  if (soundon)
    return;
  for (var i = 0; i < maxVoices; i++) {
    if (voice[i].note >= 0) {
      voice[i].env.gain.cancelScheduledValues(0);
      voice[i].env.gain.setTargetAtTime(0.0, 0, release);
    }
  }
  lfo.env.gain.value = 0;
}
function findNote(note) {
  for (i = 0; i < maxVoices; i++) {
    if (voice[i].note == note)
      return i;
  }
  return 0;
}
var steal = 0;
function nextNote(note) {
  var reuse = -1;
  var oldest = -1;
  for (var i = 0; i < maxVoices; i++) {
    if (voice[i].note == note) {
      if (reuse < 0 ||
        (reuse >= 0 && voice[i].start < voice[reuse].start))
        reuse = i;  // prefer oldest reuse
    }
    if (voice[i].note < 0) {
      if (oldest < 0)
        oldest = i;
      if (voice[i].start < voice[oldest].start)
        oldest = i;
    }
  }
  // if oldest note is in use, prefer to reuse existing same note
  if (oldest < 0 && reuse >= 0)
    return reuse;
  if (oldest < 0) {  // no unused voice, none match current note
    oldest = steal;
    steal += 1;  // round-robin which voice is stolen
    steal %= maxVoices;
  }
  return oldest;
}
function noteFreq(note) {
  return mastertune * Math.pow(2,(note-69)/12);
}

function pitchBend(value) {
  var bendrange = value < 8192 ? benddn : bendup;
  notefrac = bendrange * (value - 8192.0) / 8192.0;
  bendmult= Math.pow(2, (bendrange / 12) * (value - 8192.0) / 8192.0);
  if (soundon) {
    // modify all the playing notes by the bend value
    for (var i = 0; i < maxVoices; i++) {
      if (voice[i].note >= 0) {
        voice[i].osc.frequency.setValueAtTime(voice[i].freq * bendmult, 0);
      }
    }
  }
}
function stopDTMF(keyentry) {
  var v1 = keyentry.t1;
  var v2 = keyentry.t2;
  keyentry.t1 = keyentry.t2 = -1;
  [v1,v2].forEach(function(v) {
    if (v >= 0) {
      // immediate stop to tones
      voice[v].env.gain.cancelScheduledValues(0);
      voice[v].env.gain.setTargetAtTime(0.0, 0, 0.005);
      voice[v].note = -1;
    }
  });
}
function startDTMF(keyentry, plan) {
  var v = nextNote(256);
  var v1 = plan.r1;
  var v2 = plan.r2;
  voice[v].note = 256;
  voice[v].freq = plan.t1;
  voice[v].osc.type = 'sine';
  voice[v].osc.frequency.setValueAtTime(voice[v].freq, 0);
  voice[v].start = context.currentTime;
  voice[v].env.gain.cancelScheduledValues(0);
  voice[v].env.gain.setTargetAtTime(v1, 0, 0.005);
  keyentry.t1 = v;
  v = nextNote();
  voice[v].note = 256;
  voice[v].freq = plan.t2;
  voice[v].osc.type = 'sine';
  voice[v].osc.frequency.setValueAtTime(voice[v].freq, 0);
  voice[v].start = context.currentTime;
  voice[v].env.gain.cancelScheduledValues(0);
  voice[v].env.gain.setTargetAtTime(v2, 0, 0.005);
  keyentry.t2 = v;
}
function startNote(channel, note, velocity) {
  var i = nextNote(note);
  voice[i].note = note;
  voice[i].freq = noteFreq(note);
  voice[i].hold1 = false;
  voice[i].sostenuto = false;
  voice[i].osc.frequency.setValueAtTime(voice[i].freq * bendmult, 0);
  voice[i].osc.type = 'square';
  if (voice[i].start < 0)
    voice[i].osc.start();
  voice[i].start = context.currentTime;
  voice[i].env.gain.cancelScheduledValues(0);
  voice[i].env.gain.setTargetAtTime((velocity/127), 0, attack);
  voice[i].env.gain.setTargetAtTime((sustain * velocity/127),
    context.currentTime + attack, decay);
  // 9 to 3.3 seconds of sustain to decay to -60dB
  var sustime = 9 * Math.exp(-note/128);
  sustime = (sustime * 2) / 10;  // convert to time constant
  voice[i].env.gain.setTargetAtTime(0.001 / 127,
    context.currentTime + attack + decay, sustime); 
}
function stopSustain() {
  for (var i = 0; i < maxVoices; i++) {
    if ((voice[i].hold1 && !hold1 && !voice[i].sostenuto) ||
       (voice[i].sostenuto && !sostenuto)) {
      voice[i].sostenuto = false;
      voice[i].hold1 = false;
      voice[i].env.gain.cancelScheduledValues(0);
      voice[i].env.gain.setTargetAtTime(0.0, 0, release);
      voice[i].note = -1;
    }
  }
}
function stopNote(channel, note) {
  var i = findNote(note);
  if (i >= 0) {
    voice[i].hold1 = hold1;
    if (sostenuto) {
      voice[i].sostenuto = (sostenutolist.indexOf(note) >= 0);
    }
    voice[i].note = -1;  // mark for early reuse even if sustained
    if (voice[i].hold1 || voice[i].sostenuto) {
      return;
    }
    voice[i].env.gain.cancelScheduledValues(0);
    voice[i].env.gain.setTargetAtTime(0.0, 0, release);
  }
}

function resize()
{
  if (canvas.width != innerWidth) {
    keyscale = 0; // force reset to 88 keys on window resize/rotate
  }
  // adjust to how browser reflows transport area
  th = transport.clientHeight;
  // make config always end 43 pixels above transport area (43+32=75)
  config.style.bottom = (th + 43) + 'px';
  dw = window.innerWidth;
  dh = window.innerHeight - th;
  canvas.width = dw;
  canvas.height = dh;
  makekeys();
  if (showflames) {
    var h = dh - kh - Math.round(2 * keyscale);
    noiseimg = new ImageData(dw, h);
    fireimg1 = new ImageData(dw, h);
    fireimg2 = new ImageData(dw, h);
    makenoiseimage();
  }
}

function makekeys()
{
  if (keyscale <= 0) {
    // on reload, set initial scale to show 88, set keypan to note 21
    keyscale = 128.0 / 88.0;
    keypan = -21 * dw * keyscale / 128;
  }
  var sw = dw * keyscale;
  var sh = dh * keyscale;
  var kw = sw / (kct * 7 / 12);  // white key width (px)

  bw = sw / kct;  // black key width in pixels
  kh = Math.round(keydepth * sw / keybed); // keyboard height (px)
  bkh = Math.round(bkeydepth * sw / keybed); // black height (px)
  dy =  dh / 256;  // move 1/256 window height per frame
  var wpos = 0;

  keyboxes = [];
  for (var i = 0; i < kct; i++) {
    var n = i % 12;
    var bk = (n == 1 || n == 3 || n == 6 || n == 8 || n == 10);
    var pnote = (i >= 21 && i <= 108); // is in standard piano range?
    var x = bk ? bw * i : wpos * kw;
    var y = dh - kh;
    var w = (bk ? bw : kw);
    var h =  (bk ? bkh : kh);
    var fill = (bk ? '#000' : '#fff');
    var pfill = ccolor[0]; // replaced with channel color later
    var gradient = ctx.createLinearGradient(x+keypan, y+kh/2,
        x+keypan+kw, y+kh/2-1);
    gradient.addColorStop(0, '#0008');
    gradient.addColorStop(0.25, '#0000');

    keyboxes.push({
      x: x,
      y: y,
      w: w,
      h: h,
      v: 0,
      note: i,
      pressed: false,
      sostenuto: false,
      isBlack: bk,
      fill: fill,
      held: false,
      ptime: 0,
      sfill: '#fff',
      pfill: pfill,
      grd: gradient,
      pnote: pnote,
    });
    wpos += bk ? 0 : 1;
  }
}

var mousenote = -1;
var touchnotes = [];

function getkey(x,y) {
  var note = -1;
  x -= keypan;

  // find which black key was pressed
  for (var i = 0, j = keyboxes.length; i < j && note < 0; i++) {
    if (!keyboxes[i].isBlack) // check only black key overlays first
      continue;
    if (x >= keyboxes[i].x &&
        x < keyboxes[i].x + keyboxes[i].w &&
        y >= keyboxes[i].y &&
        y < keyboxes[i].y + keyboxes[i].h) {
      note = keyboxes[i].note;
    }
  }
  // find which white key was pressed
  for (var i = 0, j = keyboxes.length; i < j && note < 0; i++) {
    if (keyboxes[i].isBlack) // already checked black keys
      continue;
    if (x >= keyboxes[i].x &&
        x < keyboxes[i].x + keyboxes[i].w &&
        y >= keyboxes[i].y &&
        y < keyboxes[i].y + keyboxes[i].h) {
      note = keyboxes[i].note;
    }
  }
  return note;
}

function mousemove(event) {
  event.preventDefault();
  if (mousenote < 0) {
    return;
  }
  var note = getkey(event.clientX, event.clientY);
  if (note == mousenote) {
    return;
  }
  if (mousenote >= 0) {
    noteOff(mousechan, mousenote, 64);
    mousenote = -1;
  }
  if (note >= 0) {
    noteOn(mousechan, note, 127);
    mousenote = note;
  }
}

function mouseup(event) {
  event.preventDefault();
  if (event.type != 'contextmenu' && event.button == 2)
    return;  // squash this duplicated event
  if (event.clientY < 75 || event.type == 'contextmenu') {
    toggleconfig(event);
  }
  if (mousenote >= 0) {
    noteOff(mousechan, mousenote, 64);
    mousenote = -1;
  }
}
function mousedown(event) {
  event.preventDefault();
  var note;
  if (mousenote >= 0) {
    noteOff(mousechan, mousenote, 64);
    mousenote = -1;
  }
  // ignore if not in keyboard area
  if (event.y < dh - kh) {
    // todo: maybe trigger some pointer based effects in scrolly area
    return;
  }
  note = getkey(event.clientX, event.clientY);
  if (note >= 0) {
    noteOn(mousechan, note, 127);
    mousenote = note;
  }
}
function capkeyscale(scale, ypos)
{
  // cap scale at y position at ypos or 90% of window height
  ypos = Math.max(0.1 * dh, ypos);
  if (scale * kh > dh - ypos - 25) {
    scale = (dh - ypos - 25) / kh;
  }
  if (scale * keyscale < 1.0) {
    scale = 1.0 / keyscale;
  }
  return scale;
}
function updatekeypan(oldx, scale, x)
{
  keypan -= oldx;
  keypan *= scale;
  keypan += x;
  if (keypan < dw - 128 * bw * scale)
    keypan = dw - 128 * bw * scale;
  if (keypan > 0)
    keypan = 0;
}
function mousewheel(event) {
  event.preventDefault();
  var delta = event.deltaY;
  if (event.shiftKey) { // wheel + shift = pan left/right (deltaY)
    updatekeypan(0, 1.0, delta / keyscale);
    makekeys();
  } else { // wheel = touchpad pan up/down (deltaY)
    var scale = (kh + delta) / kh;
    // wheel + ctrlKey = touchpad pinch zoom (deltaY)
    if (event.ctrlKey) {
      scale = (delta < 0) ? 1.05 : 0.95;
    }
    var x = event.clientX;
    var pscale = scale;
    scale = capkeyscale(scale, 0);
    updatekeypan(x, scale, x);
    keyscale *= scale;
    makekeys();
  }
}

var oldx = -1;
var olddist = -1;
var oldxc = -1;

function handletouch(event) {
  event.preventDefault();
  var notes = [];
  var count = event.touches.length;
  if (count == 1) {
    if (oldxc < 0 && event.touches[0].clientY < 75) {
      toggleconfig(event);
      return;
    }
    if (event.touches[0].clientY < dh - kh - 2) {
      // have a single touch above the kbd, track for 1 touch kbd panning
      var x = event.touches[0].clientX;
      if (oldx >= 0) {
        updatekeypan(oldx, 1.0, x);
        makekeys();
      }
      oldx = x;
      return;
    }
  }
  oldx = -1;
  if (count == 2) {
    var kbd = dh - kh - 2;
    if (event.touches[0].clientY < kbd && event.touches[1].clientY < kbd) {
      // allow two touch keyboard scale and pan
      var x1 = event.touches[0].clientX;
      var y1 = event.touches[0].clientY;
      var x2 = event.touches[1].clientX;
      var y2 = event.touches[1].clientY;
      var d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

      var ymax = Math.max(y1, y2);
      if (olddist >= 0) {
        var scale = d / olddist;
        scale = capkeyscale(scale, ymax - 25);
        // try to land touch over same relative place on keyboard
        updatekeypan(oldxc, scale, x2);

        keyscale *= scale;

        makekeys();
      }
      olddist = d;
      oldxc = x2;
      return;
    }
  }
  olddist = -1;
  oldxc = -1;
  for (var i = 0; i < count; i++) {
    var note = getkey(event.touches[i].clientX, event.touches[i].clientY);
    if (note >= 0) {
      var force = event.touches[i].force;
      if (force <= 0) // if unknown or undefined, define 0.5 default
        force = 0.5;
      notes.push(note);
      if (touchnotes.indexOf(note) < 0) {
        noteOn(touchchan, note, Math.round(force * 127));
        touchnotes.push(note);
      }
    }
  }
  // figure out if any touched notes went away or changed
  for (var i = touchnotes.length - 1; i >= 0; i--) {
    if (notes.indexOf(touchnotes[i]) < 0) {
      noteOff(touchchan, touchnotes[i], 64);
    }
  }
  touchnotes = [...notes];
}

var keyspressed = [];
var shiftpressed = false;
var keytranspose = 60;
// table of event.code mapping to octave note offset
// event.code names should be independent of keyboard layout
// see: https://w3c.github.io/uievents-code/#key-alphanumeric-writing-system
var keytable = [
  { c:'Space', n:-12, m:-1 },
  { c:'KeyA', n:0, m:-1 },
  { c:'IntlBackslash', n:-1, m:-1 },
  { c:'KeyZ', n:0, m:-1 },
  { c:'KeyS', n:1, m:-1 },
  { c:'KeyX', n:2, m:-1 },
  { c:'KeyD', n:3, m:-1 },
  { c:'KeyC', n:4, m:-1 },
  { c:'KeyF', n:5, m:-1 },
  { c:'KeyV', n:5, m:-1 },
  { c:'KeyG', n:6, m:-1 },
  { c:'KeyB', n:7, m:-1 },
  { c:'KeyH', n:8, m:-1 },
  { c:'KeyN', n:9, m:-1 },
  { c:'KeyJ', n:10, m:-1 },
  { c:'KeyM', n:11, m:-1 },
  { c:'KeyK', n:12, m:-1 },
  { c:'Comma', n:12, m:-1 },
  { c:'KeyL', n:13, m:-1 },
  { c:'Period', n:14, m:-1 },
  { c:'Semicolon', n:15, m:-1 },
  { c:'Slash', n:16, m:-1 },
  { c:'Quote', n:17, m:-1 },
  { c:'IntlRo', n:17, m:-1 },
  { c:'Backquote', n:10, m:-1 },
  { c:'Digit1', n:12, m:-1 },
  { c:'KeyQ', n:12, m:-1 },
  { c:'Digit2', n:13, m:-1 },
  { c:'KeyW', n:14, m:-1 },
  { c:'Digit3', n:15, m:-1 },
  { c:'KeyE', n:16, m:-1 },
  { c:'Digit4', n:17, m:-1 },
  { c:'KeyR', n:17, m:-1 },
  { c:'Digit5', n:18, m:-1 },
  { c:'KeyT', n:19, m:-1 },
  { c:'Digit6', n:20, m:-1 },
  { c:'KeyY', n:21, m:-1 },
  { c:'Digit7', n:22, m:-1 },
  { c:'KeyU', n:23, m:-1 },
  { c:'KeyI', n:24, m:-1 },
  { c:'Digit8', n:24, m:-1 },
  { c:'Digit9', n:25, m:-1 },
  { c:'KeyO', n:26, m:-1 },
  { c:'Digit0', n:27, m:-1 },
  { c:'KeyP', n:28, m:-1 },
  { c:'Minus', n:29, m:-1 },
  { c:'BracketLeft', n:29, m:-1 },
  { c:'Equal', n:30, m:-1 },
  { c:'IntlYen', n:32, m:-1 },
  { c:'BracketRight', n:31, m:-1 },
  { c:'Backslash', n:33, m:-1 },
  { c:'ArrowDown', n:-128, m:-1 },
  { c:'ArrowUp', n:128, m:-1 },
  { c:'ArrowLeft', n:-1, m:-1 },
  { c:'ArrowRight', n:1, m:-1 },
  { c:'ShiftLeft', n:-1, m:-1 },
  { c:'ShiftRight', n:1, m:-1 },
  // DMTF
  { c:'Numpad0', n:0, t1:-1, t2:-1 },
  { c:'Numpad1', n:1, t1:-1, t2:-1 },
  { c:'Numpad2', n:2, t1:-1, t2:-1 },
  { c:'Numpad3', n:3, t1:-1, t2:-1 },
  { c:'Numpad4', n:4, t1:-1, t2:-1 },
  { c:'Numpad5', n:5, t1:-1, t2:-1 },
  { c:'Numpad6', n:6, t1:-1, t2:-1 },
  { c:'Numpad7', n:7, t1:-1, t2:-1 },
  { c:'Numpad8', n:8, t1:-1, t2:-1 },
  { c:'Numpad9', n:9, t1:-1, t2:-1 },
  { c:'NumpadMultiply', n:10, t1:-1, t2:-1 }, //*
  { c:'NumpadDivide', n:11, t1:-1, t2:-1 },   //#
  { c:'NumpadSubtract', n:12, t1:-1, t2:-1 }, //A
  { c:'NumpadAdd', n:13, t1:-1, t2:-1 },      //B
  { c:'NumpadEnter', n:14, t1:-1, t2:-1 },    //C
  { c:'NumpadDecimal', n:15, t1:-1, t2:-1 },  //D
  { c:'PageDown', n:16, t1:-1, t2:-1 },  //north america dialtone
  { c:'PageUp', n:17, t1:-1, t2:-1 },  //north america ringback
  { c:'Delete', n:18, t1:-1, t2:-1 },  //north america busy
];

var rMF = dbRatio(-7);
var ss5 = [
  { t1:1300,t2:1500, n:"MF0", r1:rMF, r2:rMF },
  { t1:700,t2:900, n:"MF1", r1:rMF, r2:rMF },
  { t1:700,t2:1100, n:"MF2", r1:rMF, r2:rMF },
  { t1:900,t2:1100, n:"MF3", r1:rMF, r2:rMF },
  { t1:700,t2:1300, n:"MF4", r1:rMF, r2:rMF },
  { t1:900,t2:1300, n:"MF5", r1:rMF, r2:rMF },
  { t1:1100,t2:1300, n:"MF6", r1:rMF, r2:rMF },
  { t1:700,t2:1500, n:"MF7", r1:rMF, r2:rMF },
  { t1:900,t2:1500, n:"MF8", r1:rMF, r2:rMF }, 
  { t1:1100,t2:1500, n:"MF9", r1:rMF, r2:rMF },
  { t1:700,t2:1700, n:"ST3P", r1:rMF, r2:rMF },
  { t1:900,t2:1700, n:"STP", r1:rMF, r2:rMF }, 
  { t1:1100,t2:1700, n:"KP1", r1:rMF, r2:rMF },
  { t1:1300,t2:1700, n:"KP2", r1:rMF, r2:rMF },
  { t1:1500,t2:1700, n:"ST", r1:rMF, r2:rMF },
  { t1:2600,t2:2600, n:"2600", r1:dbRatio(-6), r2:dbRatio(-6) },
  { t1:2400,t2:2600, n:"2400+2600", r1:dbRatio(-6), r2:dbRatio(-6) },
  { t1:400,t2:450, n:"UK Ring", r1:dbRatio(-19), r2:dbRatio(-19) },
  { t1:2400,t2:2400, n:"2400", r1:dbRatio(-6), r2:dbRatio(-6) },
];

var rLow = dbRatio(-11);
var rHigh = dbRatio(-9);
var dtmf = [
  { t1:941,t2:1336, n:"0", r1:rLow, r2:rHigh },
  { t1:697,t2:1209, n:"1", r1:rLow, r2:rHigh },
  { t1:697,t2:1336, n:"2", r1:rLow, r2:rHigh },
  { t1:697,t2:1477, n:"3", r1:rLow, r2:rHigh },
  { t1:770,t2:1209, n:"4", r1:rLow, r2:rHigh },
  { t1:770,t2:1336, n:"5", r1:rLow, r2:rHigh },
  { t1:770,t2:1477, n:"6", r1:rLow, r2:rHigh },
  { t1:852,t2:1209, n:"7", r1:rLow, r2:rHigh },
  { t1:852,t2:1336, n:"8", r1:rLow, r2:rHigh },
  { t1:852,t2:1477, n:"9", r1:rLow, r2:rHigh },
  { t1:941,t2:1209, n:"*", r1:rLow, r2:rHigh },
  { t1:941,t2:1477, n:"#", r1:rLow, r2:rHigh },
  { t1:697,t2:1633, n:"A", r1:rLow, r2:rHigh },
  { t1:770,t2:1633, n:"B", r1:rLow, r2:rHigh },
  { t1:852,t2:1633, n:"C", r1:rLow, r2:rHigh },
  { t1:941,t2:1633, n:"D", r1:rLow, r2:rHigh },
  { t1:350,t2:440, n:"NA Dial", r1:dbRatio(-13), r2:dbRatio(-13) },
  { t1:480,t2:440, n:"NA Ring", r1:dbRatio(-19), r2:dbRatio(-19) },
  { t1:480,t2:620, n:"NA Busy", r1:dbRatio(-24), r2:dbRatio(-24) },
];

// return index of event.code in keytable, -1 if not found
function keyindex(code) {
  for (var i = 0, j = keytable.length; i < j; i++) {
    if (keytable[i].c == code)
      return i;
  }
  return -1;
}

function keydown(event) {
  if (event.code == 'F12') {
    return;  // allow F12 dev console access
  }
  if (showconfig) return;
  event.preventDefault();
  var i = keyindex(event.code);
  if (i < 0)
    return;
  if (event.code == 'ArrowLeft' || event.code == 'ArrowRight') {
    updatekeypan(bw * keytable[i].n, 1, 0);
    makekeys();
    return;
  }
  if (keyspressed.indexOf(i) < 0) {
    keyspressed.push(i);
  } else
    return; // key was already tracked as pressed
  var n = keytable[i].n;
  if (keytable[i].hasOwnProperty('t1')) {
    if (soundon) {
      var plan = shiftpressed ? ss5[n] : dtmf[n];
      startDTMF(keytable[i], plan);
    }
    return;
  }
  if (event.code == 'ShiftLeft' || event.code == 'ShiftRight') {
    shiftpressed = true;
    return;
  }
  if (n == -128) {
    keytranspose -= (shiftpressed ? 1 : 12);
    if (keytranspose < 0)
      keytranspose = 0;
    return;
  }
  if (n == 128) {
    keytranspose += (shiftpressed ? 1 : 12);
    if (keytranspose > 96)
      keytranspose = 96;
    return;
  }
  n = keytranspose + n;
  if (n < 0 || n > 127)
    return;
  keytable[i].m = n;  // mark midi note playing for key
  noteOn(keychan, n, 96);
}

function keyup(event) {
  if (event.code == 'F12') {
    return;  // allow F12 dev console access
  }
  if (event.code == 'Escape' || event.code == 'ContextMenu') {
    toggleconfig(event);
    return;
  }
  if (showconfig) return;
  event.preventDefault();
  if (event.code == 'ControlLeft') {
    cc67(keychan, soft ? 0 : 127);
    return;
  }
  if (event.code == 'AltLeft') {
    cc66(keychan, sostenuto ? 0 : 127);
    return;
  }
  if (event.code == 'ControlRight') {
    cc64(keychan, hold1 ? 0 : 127);
    return;
  }
  var i = keyindex(event.code);
  if (i < 0)
    return;
  var j = keyspressed.indexOf(i);
  if (j < 0)
    return;  // got key up for key not tracked as pressed
  keyspressed.splice(j, 1);  // remove key from list of keys pressed
  if (event.code == 'ShiftLeft' || event.code == 'ShiftRight') {
    shiftpressed = false;
    return;
  }
  if (keytable[i].hasOwnProperty('t1')) {
    if (soundon) {
      // kill active dtmf voices for key
      stopDTMF(keytable[i]);
    }
    return;
  }
  var n = keytable[i].m;
  keytable[i].m = -1; // no midi note playing for key
  if (n < 0 || n > 127)
    return;   // octave keys also fall out here
  noteOff(keychan, n, 64);
}

function initaudio(event) {
  // patch up prefixes
  window.AudioContext=window.AudioContext||window.webkitAudioContext;
  context = new AudioContext();

  lfo = {
    osc: context.createOscillator(),
    env: context.createGain(),
    freq: noteFreq(0),
    start: -1,
  }
  lfo.osc.frequency.value = lfo.freq;
  lfo.osc.type = 'triangle';
  lfo.env.gain.value = 0;
  lfo.osc.connect(lfo.env);
  lfout = context.createAnalyser();
  lfout.fftSize = 32;
  lfo.env.connect(lfout);
  lfdata = new Float32Array(lfout.frequencyBinCount);
  mastervol = context.createGain();
  mastervol.connect(context.destination);
  mastervol.gain.value = dbRatio(-10);
  fftout = context.createAnalyser();
  fftout.fftSize = 256;
  fftout.minDecibels = -96;
  fftout.maxDecibels = 0;
  fftout.smoothingTimeConstant = 0;
  fftdata = new Uint8Array(fftout.frequencyBinCount);
  mastervol.connect(fftout);
  for (i = 0; i < maxVoices; i++) {
    // set up the basic oscillator chain, muted to begin with.
    var oscillator = context.createOscillator();
    var envelope = context.createGain();
    oscillator.frequency.value = 0;
    oscillator.connect(envelope);
    lfo.env.connect(oscillator.detune);
    envelope.connect(mastervol);
    envelope.gain.value = 0.0;  // Mute the sound
    voice.push({
      start: -1,
      note: -1,
      freq: 0,
      hold1: false,
      sostenuto: false,
      osc: oscillator,
      env: envelope,
    });
  }
}
function selectmidi() {
  cfgform.midiin.options.length = 0;
  cfgform.midiout.options.length = 0;
  cfgform.midictrl.options.length = 0;
  midiinputs.forEach(function(input) {
    if (midiin == null && input.id != 'none') {
      midiin = input.id;
    }
    var sel = (midiin == input.id);
    var csel = (midictrl == input.id);
    cfgform.midiin.options.add(new Option(input.id + " - " +
      input.name, input.id, sel, sel));
    cfgform.midictrl.options.add(new Option(input.id + " - " +
      input.name, input.id, csel, csel));
  });
  midioutputs.forEach(function(output) {
    var sel = (midiout == output.id);
    cfgform.midiout.options.add(new Option(output.id + " - " +
      output.name, output.id, sel, sel));
  });
}
function connectMIDI() {
  midiinputs = [];
  midiinputs.push({ id:'none', name:'disabled', type:'input' });
  midiinputs.push({ id:'all', name:'enabled', type:'input' });
  midiAccess.inputs.forEach(function(input) {
    input.onmidimessage = midimessage;
    midiinputs.push({
      id: input.id,
      name: input.name,
      type: input.type,
    });
  });
  midioutputs = [];
  midioutputs.push({ id:'none', name:'disabled', type:'output' });
  midiAccess.outputs.forEach(function(output) {
    midioutputs.push({
      id: output.id,
      name: output.name,
      type: output.type,
    });
  });
  selectmidi();  // update possible midi selections
}
function gotMIDI(midi) {
  midiAccess = midi;
  connectMIDI();
  midiAccess.onstatechange=connectMIDI;
}
function deniedMIDI(err) {
  midiout = midiin = midictrl = null;
}
var tempo = {
  val:0,
  first:0,
  last:0,
  avgms:0,
  ms:0,
  count:0,
  beats:0,
}
function midimessage(event) {
  if (midiin != 'all' && event.target.id != midiin)
    return;  // if user selected a device, ignore all the rest
  var now = Math.floor(event.timeStamp);  // no data in fractional part
  midilog.push({ data:event.data, src:event.target.id, time:now,
  });  // how big can this grow?
  var channel = event.data[0] & 0x0f;
  switch (event.data[0] & 0xf0) {
    case midi_status.SYSTEM_PREFIX:
      if (event.data[0] == midi_sys.START) {
        tempo.beats = 0;
      }
      if (event.data[0] == midi_sys.TIMING_CLOCK) {
        if  (tempo.beats % 24 < 12) {
          taptempo.style.background="#ff0";
        } else {
          taptempo.style.background="";
        }
        tempo.beats++;
        tempo.count++;
        if (now > tempo.last) {
          tempo.ms = now - tempo.last;
          tempo.avgms = (now - tempo.first) / tempo.count;
          if (Math.abs(tempo.ms - tempo.avgms) > 2) {
            tempo.count = 0;  // restart long running avg
            tempo.avgms = tempo.ms;
          }
          tempo.val = (2500 / tempo.avgms).toFixed(1);
        }
        if (tempo.count == 0)
          tempo.first = now;
        tempo.last = now;
      }
      break;
    case midi_status.CTL_CHANGE:
      switch(event.data[1]) {
        case midi_ctl.MODWHEEL:
          cc01(channel, event.data[2]);
          break;
        case midi_ctl.HOLD1:
          cc64(channel, event.data[2]);
          break;
        case midi_ctl.SOSTENUTO:
          cc66(channel, event.data[2]);
          break;
        case midi_ctl.SOFT_PEDAL:
          cc67(channel, event.data[2]);
          break;
      }
      break;
    case midi_status.PITCH_BEND:
      pitchBend(event.data[1] | (event.data[2] << 7));
      break;
    case midi_status.NOTEON:
      if (event.data[2]!=0) {  // if velocity != 0, this is a note-on message
        noteOn(channel, event.data[1], event.data[2]);
        break;
      }
      // if velocity == 0, fall through to note off case
    case midi_status.NOTEOFF:
      noteOff(channel, event.data[1]);
      break;
  }
}
function cc01(channel, value) {
  var modwheel = value / 127;
  // do this whether or not sound is on for modulation rendering
  lfo.env.gain.value = moddepth * modwheel;
}
function cc64(channel, value) {
  hold1 = (value >= 64);
  if (!hold1) {
    for (var i = 0; i < kct; i++)
      keyboxes[i].held = false;
    if (soundon) {
      // kill all the playing notes that got noteoff already
      stopSustain();
    }
  }
}
function cc66(channel, value) {
  sostenuto = (value >= 64);
  if (sostenuto) {
    // record notes currently on
    sostenutolist = [];
    for (var i = 0; i < kct; i++) {
      if (keyboxes[i].pressed)
        sostenutolist.push(i);
    }

  } else {
    for (var i = 0; i < kct; i++) {
      keyboxes[i].sostenuto = false;
    }
    if (soundon)
      stopSustain();
  }
}
function cc67(channel, value) {
  soft = (value >= 64);
}
function noteOn(channel, noteNumber, velocity) {
  if (soft)
    velocity /= 3.0;
  noteboxes.push(new NoteBox(channel, noteNumber, velocity));
  if (noteNumber < kct) {
    keyboxes[noteNumber].v = velocity;
    keyboxes[noteNumber].ptime = context.currentTime;
    keyboxes[noteNumber].pressed = true;
    keyboxes[noteNumber].pfill = ccolor[channel] + '33';
    keyboxes[noteNumber].sfill = ccolor[channel] + 'ff';
  }
  if (soundon) {
    startNote(channel, noteNumber, velocity);
  }
}
function noteOff(channel, noteNumber) {
  for (var i = 0, j = noteboxes.length; i < j; i++) {
    if (noteboxes[i].n == noteNumber)
      noteboxes[i].playing = false;
  }
  if (noteNumber < kct) {
    keyboxes[noteNumber].pressed = false;
    keyboxes[noteNumber].held = hold1;
    if (sostenuto) {
      keyboxes[noteNumber].sostenuto =
        (sostenutolist.indexOf(noteNumber) >= 0);
    }
  }
  if (soundon) {
    stopNote(channel, noteNumber);
  }
}

// add a round rectangle function
ctx.roundRect = function(x,y,w,h,r) {
  if (r > h / 2)
    r = h / 2;
  if (r > w / 2)
    r = w / 2;
  var r2 = r;
  // square off tops and bottoms when they hit edges
  if ((1+dh-kh)-(y+h) < r) {
    r2 = (1+dh-kh)-(y+h);
    if (r2 < 1)
      r2 = 0;
  }
  if(y < r)
    r = y < 0 ? 0 : y;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);  // top
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r2); // right
  ctx.quadraticCurveTo(x + w, y + h, x + w - r2, y + h);
  ctx.lineTo(x + r2, y + h);  // bottom
  ctx.quadraticCurveTo(x, y + h, x, y + h - r2);
  ctx.lineTo(x, y + r); // left
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

var lasttime = 0;
var fps = 0;
var framerate = 1000.0 / 60.0;  // expected update 60fps

var npos = 0;

function updatefire() {
  var w = fireimg1.width;
  var h = fireimg1.height;

  noteseed();
  for (var y = h - 2; y > 2; y--) {
    for (var x = 1; x < w - 1; x++) {
      var offset = x * 4 + y * w * 4;
      var o1 = offset + 4;
      var o2 = offset - 4;
      var o3 = offset + w * 4;
      var o4 = offset - 2 * w * 4;

      var c = noiseimg.data[x * 4 + ((npos + y) % h) * w * 4];
      var p = (fireimg1.data[o1] + fireimg1.data[o2] +
        fireimg1.data[o3] + fireimg1.data[o4]) / 4;
      p -= c;

      if (p < 0)
        p = 0
      // write pixel value to buffer2 one pixel higher
      fireimg2.data[o4] = Math.round(p);
      fireimg2.data[o4+1] = p < 174 ? 0 : p * 174 / 255;
      fireimg2.data[o4+2] = p < 20 ? 0 : p * 20 / 255;
      fireimg2.data[o4+3] = p < 20 ? 0 : 255;
    }
  }
  npos += 1;
  npos %= h;
  fireimg1.data.set(fireimg2.data);
  ctx.putImageData(fireimg1, 0, 0);
}

var rseed = 0;
function msrandom() {
  rseed = rseed * 214013 + 2531011;
  rseed &= 0xffffffff;
  return (rseed >> 16) & 0x7fff;
}
function msrandomf() {
  rseed = rseed * 214013 + 2531011;
  rseed &= 0xffffffff;
  return ((rseed >> 16) & 0x7fff) / 0x7fff;
}

var PERLIN_YWRAPB = 4;
var PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
var PERLIN_ZWRAPB = 8;
var PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
var PERLIN_SIZE = 4095;

var perlin_octaves = 4; // default to medium smooth
var perlin_amp_falloff = 0.5; // 50% reduction/octave

var scaled_cosine = function(i) {
  return 0.5 * (1.0 - Math.cos(i * Math.PI));
};

var perlin; // will be initialized lazily by noise() or noiseSeed()

var noise = function(x, y, z) {
  y = y || 0;
  z = z || 0;

  if (perlin == null) {
    perlin = new Array(PERLIN_SIZE + 1);
    for (var i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = msrandomf();
    }
  }

  if (x < 0) {
    x = -x;
  }
  if (y < 0) {
    y = -y;
  }
  if (z < 0) {
    z = -z;
  }

  var xi = Math.floor(x),
    yi = Math.floor(y),
    zi = Math.floor(z);
  var xf = x - xi;
  var yf = y - yi;
  var zf = z - zi;
  var rxf, ryf;

  var r = 0;
  var ampl = 0.5;

  var n1, n2, n3;

  for (var o = 0; o < perlin_octaves; o++) {
    var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);

    rxf = scaled_cosine(xf);
    ryf = scaled_cosine(yf);

    n1 = perlin[of & PERLIN_SIZE];
    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);
    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
    n1 += ryf * (n2 - n1);

    of += PERLIN_ZWRAP;
    n2 = perlin[of & PERLIN_SIZE];
    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);
    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
    n2 += ryf * (n3 - n2);

    n1 += scaled_cosine(zf) * (n2 - n1);

    r += n1 * ampl;
    ampl *= perlin_amp_falloff;
    xi <<= 1;
    xf *= 2;
    yi <<= 1;
    yf *= 2;
    zi <<= 1;
    zf *= 2;

    if (xf >= 1.0) {
      xi++;
      xf--;
    }
    if (yf >= 1.0) {
      yi++;
      yf--;
    }
    if (zf >= 1.0) {
      zi++;
      zf--;
    }
  }
  return r;
};
var noiseDetail = function(lod, falloff) {
  if (lod > 0) {
    perlin_octaves = lod;
  }
  if (falloff > 0) {
    perlin_amp_falloff = falloff;
  }
};

var noiseSeed = function(seed) {
  // Linear Congruential Generator
  // Variant of a Lehman Generator
  var lcg = (function() {
    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
    // m is basically chosen to be large (as it is the max period)
    // and for its relationships to a and c
    var m = 4294967296;
    // a - 1 should be divisible by m's prime factors
    var a = 1664525;
    // c and m should be co-prime
    var c = 1013904223;
    var seed, z;
    return {
      setSeed: function(val) {
        // pick a random seed if val is undefined or null
        // the >>> 0 casts the seed to an unsigned 32-bit integer
        z = seed = (val == null ? msrandomf() * m : val) >>> 0;
      },
      getSeed: function() {
        return seed;
      },
      rand: function() {
        // define the recurrence relationship
        z = (a * z + c) % m;
        // return a float in [0, 1)
        // if z = m then z / m = 0 therefore (z % m) / m < 1 always
        return z / m;
      }
    };
  })();

  lcg.setSeed(seed);
  perlin = new Array(PERLIN_SIZE + 1);
  for (var i = 0; i < PERLIN_SIZE + 1; i++) {
    perlin[i] = lcg.rand();
  }
};

function makenoiseimage() {
  var w = noiseimg.width;
  var h = noiseimg.height;

  for (var y = 0; y < h; y++) {
    for (var x = 0; x < w; x++) {
      var offset = x * 4 + y * w * 4;
      v = noise(x * 15 / w, y * 15 / h) * 15;
      //var v = msrandom() & 0x0f;
      noiseimg.data[offset] = v;
    }
  }
}
function noteseed() {
  var w = fireimg1.width;
  var h = fireimg1.height;
  var seed = ctx.getImageData(0, 0, dw, dh - kh - 2);
  var offset = (h - h) * w * 4;
  for (var i = 0, j = seed.data.length; i < j; i += 4) {
    if (seed.data[i] > 0 || seed.data[i + 1] > 0 ||
      seed.data[i + 2] > 0) {
      fireimg1.data[offset + i] = 255;
      fireimg1.data[offset + i + 3] = 255;
    }
  }
}
function Dot(x, y, dx, dy, c) {
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this.c = c;
  this.update = function() {
    this.x += this.dx;
    this.y += this.dy;
    this.dy += gravity;
    if (this.y > dh - kh - 2) {
      this.dx = this.dy = 0;
    }
    ctx.fillStyle = this.c;
    ctx.fillRect(this.x, this.y, psize, psize);
  }
}
var splortstart = 0;
var splortmax = 0.125;
var sparktime = 0;
function drawspark(thiskey, ts) {
  var dt = ts - thiskey.ptime;
  var splorttime = ts - splortstart;
  if (splorttime > 4 && ts - sparktime > 0.125)
    splortstart = ts;
  sparktime = ts;
  if (dt > 6) {
    return;
  }
  var smod = (9 - dt) / 9;
  if (showflames)
    smod *= 0.75;
  var size = thiskey.w * smod;
  var x = keypan + thiskey.x + thiskey.w / 2;
  var y = thiskey.y+1;
  var rot = Math.PI/2;
  var points = Math.floor(msrandomf() * 5) + 20;
  var dangle = Math.PI / points;
  var vmod = Math.sqrt(thiskey.v) / 10;
  var fangle = Math.sin(thiskey.note * Math.PI/16 + ts*3) * Math.PI/8;
  ctx.beginPath();
  ctx.moveTo(x + size, y);
  for (var i = 0; i <= points; i++) {
    var wiggle = i > 0 && i < points ?
      msrandomf() * dangle / 2 - dangle / 4 : 0;
    var dx = Math.sin(i * dangle + wiggle + rot);
    var dy = Math.cos(i * dangle + wiggle + rot);
    var r = msrandomf() * size/2 + size;
    var v = msrandomf() * 6 + 6;
    v *= smod;
    if (i & 1) {
      r *= 0.55;
    } else if (i > points / 2 - 5 && i < points / 2 + 5) {
      // for the five "middle" spark points, shoot particles
      v *= vmod;
      var c = v > 11.5 ? '#fff' : thiskey.sfill;
      if (splorttime < splortmax) {
        dx = Math.sin(2*rot+wiggle);
        dy = Math.cos(2*rot+wiggle);
        v += 16;
      } else if (showfountain) {
        dx = Math.sin(2*rot+fangle+wiggle);
        dy = Math.cos(2*rot+fangle+wiggle);
        v += 10;
      }
      var newx = x + r * dx;
      var newy = y + r * dy;
      particles.push(new Dot(newx, newy, v * dx, v * dy, c));
    }
    ctx.lineTo(x + r * dx, y + r * dy);
  }
  ctx.moveTo(x - size, y);
  ctx.closePath();
  ctx.strokeStyle = thiskey.sfill;
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.stroke();
}
function drawkeyboard() {
  if (keyshadow) {
    ctx.save();
    ctx.shadowColor = 'rgb(96,96,96,1)';
    ctx.shadowOffsetX = ctx.shadowOffsetY = 2;
    ctx.shadowBlur = 7;
  }
  // draw white keys first
  ctx.strokeStyle = '#000';
  for (var i = 0, j = keyboxes.length; i < j; i++) {
    if (keyboxes[i].isBlack)
      continue;
    if (whiteimg != null) {
      koff = keyboxes[i].pressed ? 6 : 0;
      ctx.drawImage(whiteimg, 0, 0,
        whiteimg.naturalWidth, whiteimg.naturalHeight - koff,
        keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    } else {
      ctx.fillStyle = keyboxes[i].fill;
      ctx.beginPath();
      ctx.rect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
      ctx.fill();
      ctx.stroke();
    }
    if (!keyboxes[i].pnote) {
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    }
    if (keyboxes[i].pressed) {
      if (!shadow) {
        ctx.fillStyle = keyboxes[i].grd;
        ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
          keyboxes[i].w, keyboxes[i].h);
        shadow = true;
      }
      ctx.fillStyle = keyboxes[i].pfill;
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    } else {
        shadow = false;
    }
    if (bw > 5 && (i % 12) == 0) {
      // place note name centered on the bottom of every c
      var off = keyboxes[i].pressed ? 6 : 0;
      var oct = i / 12 - 1;
      var txt = 'C' + oct;
      ctx.save()
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.font = '10px sans-serif';
      var tw = ctx.measureText('C-1');  // scale size for largest
      var scale = keyboxes[i].w / tw.width;
      var px = Math.floor(10 * scale);
      ctx.font = px + 'px sans-serif';
      tw = ctx.measureText(txt);
      ctx.fillText(txt, keypan + keyboxes[i].x +
        keyboxes[i].w/2 - tw.width/2, keyboxes[i].y + 0.9 * kh + off);
      ctx.fill();
      ctx.restore()
    }
  }
  // draw black keys on top
  for (var i = 0, j = keyboxes.length; i < j; i++) {
    if (showoctaves && i % 12 == 0) {  // draw thin octave lines
      ctx.strokeStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(keypan + keyboxes[i].x, keyboxes[i].y);
      ctx.lineTo(keypan + keyboxes[i].x, 0);
      ctx.stroke();
    }
    if (!keyboxes[i].isBlack)
      continue;
    if (blackimg != null) {
      koff = keyboxes[i].pressed ? 6 : 0;
      ctx.drawImage(blackimg, 0, 0,
        blackimg.naturalWidth, blackimg.naturalHeight - koff,
        keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    } else {
      ctx.fillStyle = keyboxes[i].fill;
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    }
    if (!keyboxes[i].pnote) {
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    }
    if (keyboxes[i].pressed) {
      ctx.fillStyle = 'rgba(255,255,255,0.33)';
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
      ctx.fillStyle = keyboxes[i].pfill;
      ctx.fillRect(keypan + keyboxes[i].x, keyboxes[i].y,
        keyboxes[i].w, keyboxes[i].h);
    }
  }
  if (keyshadow) {
    ctx.restore();
  }
}

function NoteBox(channel, noteNumber, velocity) {
  this.y = canvas.height - kh;
  this.h = 1;
  this.n = noteNumber;
  this.v = velocity;
  this.playing = true;
  this.pfill = ccolor[channel];

  this.update = function(dt) {
    var y = this.y;
    var h = this.h;
    var n = this.n;
    var v = this.v;
    var x = keyboxes[n].x + keypan + bw * modoff + bw * notefrac;

    this.y -= dy * dt / framerate;
    if (this.playing == true) {
      this.h += dy * dt / framerate;
      if (this.h > dh - kh) {
        // clip tall notes to viewing area
        this.h = dh - kh;
        this.y = 0;
      }
    }
    ctx.fillStyle = this.pfill + (88 + v).toString(16);
    ctx.strokeStyle = this.pfill + 'ff';
    ctx.roundRect(x, y, keyboxes[n].w, h, bw);
    ctx.fill();
    ctx.stroke();
  }
}

var fftcount = 0;
var ffthist = [];
var ffthistmax = 48;
function drawfft() {
  if (showflames) return;
  fftcount++;
  if ((fftcount & 1) == 0) {
    fftout.getByteFrequencyData(fftdata);
    ffthist.push(new Uint8Array(fftdata));
    if (ffthist.length > ffthistmax) {
      ffthist.splice(0, ffthist.length - ffthistmax);
    }
  }
  var len = fftout.frequencyBinCount;
  var histcount = ffthist.length;
  var yc = dh - kh - ffthistmax*2 - 2;
  for (var j = 0; j < histcount; j++) {
    for (var i = 0; i < len; i++) {
      var p = ffthist[j][i];
      if (!p) continue;
      ctx.fillStyle = 'hsl('+(180-p*360/255)+',100%,50%)';
      ctx.fillRect(i*2 + j, yc + j*2 - (fftcount&1), 2, -p/25.5);
    }
  }
}

ctx.font = '11px sans-serif';
function animate(timestamp) {
  var dt = timestamp - lasttime;
  requestAnimationFrame(animate);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // webkit is missing getFloatTimeDomainData, just use 0 if missing
  if (lfout && lfout.getFloatTimeDomainData != undefined) {
    lfout.getFloatTimeDomainData(lfdata);
    if (showspect) {
      drawfft();
    }
  }
  modoff = lfdata[0] / 100;
  // update particles
  for (var i = 0, j = particles.length; i < j; i++) {
    particles[i].update();
  }
  // delete particles that fall off screen
  for (var i = particles.length - 1; i >= 0; i--) {
    if (particles[i].y > dh - kh - 2) {
      particles.splice(i, 1);
    }
  }
  // delete particles if length grows too far
  if (particles.length > maxparticles) {
    particles.splice(0, particles.length - maxparticles);
  }
  if (keyalpha > 0)
    drawkeyboard();
  for (var i = 0, j = noteboxes.length; i < j; i++) {
    noteboxes[i].update(dt);
  }
  // delete noteboxes that scroll off screen
  for (var i = noteboxes.length - 1; i >= 0; i--) {
    if (noteboxes[i].y + noteboxes[i].h < 0) {
      noteboxes.splice(i, 1);
    }
  }
  ctx.beginPath();  // seems required to stop artifact
  // draw red line at the top of keys
  ctx.fillStyle = '#f00';
  ctx.fillRect(0, dh - kh - 2*keyscale, dw, 1+2*keyscale);

  // draw sparks for all notes pressed or held
  for (var i = 0; i < kct; i++) {
    if ((keyboxes[i].x + keyboxes[i].w + keypan < 0) ||
      (keyboxes[i].x + keypan > dw)) {
      continue;  // skip keys outside view
    }
    if (keyboxes[i].pressed || keyboxes[i].held ||
      keyboxes[i].sostenuto) {
      drawspark(keyboxes[i], context.currentTime);
    }
  }
  // draw fire on top of it all...
  if (showflames) {
    updatefire();
  }

  if (keyalpha <= 0) {
    //ctx.clearRect(0, canvas.height - kh, canvas.width, canvas.height);
  } else if (keyalpha < 1) { 
    ctx.fillStyle = 'rgba(0, 0, 119,'+(1-keyalpha)+')';
    ctx.fillRect(0, canvas.height - kh, canvas.width, canvas.height);
  }
  if (showdebug) {
    ctx.fillStyle = '#ffd';
    if (dt > 0) {
      var newfps = (1000/dt);
      if (fps <= 5)
        fps = newfps;  // seed moving average at startup
      // calculate weighted moving average fps
      fps = 0.98 * fps + 0.02 * newfps;
      ctx.fillText(Math.round(fps) +' fps', 30, 15);
    }
    var lines = 32;
    for (var i = 1, j = midilog.length; i < lines && j - i >= 0; i++) {
      var d = midilog[j-i].data;
      var s = midilog[j-i].src;
      var t = midilog[j-i].time;
      var y = 75 + 15 * (lines - i);
      var hexmidi = '';
      d.forEach(function(b) {
        hexmidi += ' ' + (b + 256).toString(16).substr(-2);
      });
      ctx.fillText(j-i + ': ' + s + ' ' +  t + ' ' + hexmidi, 30, y);
    }
  }
  if (tempo.val > 0) {
    settempo.value = tempo.val;
  }
  if (context.state == 'suspended') {
    ctx.fillStyle = '#fff';
    ctx.fillText('Audio context suspended: click or tap ' +
       'play (or here) to start...', 25, 65);
  }
  lasttime = timestamp;
};

//]]>
</script>
</body>
</html>
